---
lang: es
number-sections: true
format: 
  html:
    code-link: true
    code-fold: true
    code-summary: "Desplegar c칩digo"
    code-line-numbers: true
    code-block-background: "red"
    smooth-scroll: true
    link-external-icon: true
    linkcolor: "#ee4121"
    link-external-newwindow: true
    embed-resources: true
    # https://quarto.org/docs/reference/formats/html.html#table-of-contents
    toc: true
    toc-float: false
    toc-location: left
    toc-title: "칈ndice"
    theme: 
      - darkly
      - mystyles.scss
    backgroundcolor: "black"
    fontcolor: "white"
    mainfont: Titillium Web
editor: source
editor_options: 
  chunk_output_type: console
crossref:
  chapters: true
  fig-prefix: "figura"
  sec-prefix: "secci칩n"
execute: 
  eval: true
  echo: true
  message: false
  warning: false
---

<!-- https://ucsb-meds.github.io/customizing-quarto-websites/#/title-slide -->

<!-- logo al inicio -->
![](pic/logo.jpeg)

<!-- agregar '{.unnumbered}' remueve la numeraci칩n del header -->
<!-- https://quarto.org/docs/output-formats/html-basics.html#section-numbering -->

<!-- posici칩n de toc -->
<!-- https://rpubs.com/stevepowell99/floating-css -->

<!-- que el contenido (imagen, code) se desplace a la derecha -->
<!-- https://quarto.org/docs/authoring/article-layout.html#overflowing-content -->

# El 칰nico podcast del mundo {.unnumbered}

<!-- c칩mo personalizar el hiperv칤nculo interno de referencias cruzadas -->
<!-- https://quarto.org/docs/books/book-crossrefs.html#creating-references -->

[<ht>HOY TRASNOCHE</ht>](https://open.spotify.com/show/6C4MdNWQSPhmzBlIVau30e) es el podcast de cine definitivo. Conducido por **Fiorella Sargenti** y **Santiago Calori**, producido por [POSTA](https://www.posta.fm/podcast/hoy-trasnoche/), es un programa semanal (usualmente los viernes) en el que durante 1 hora se habla de 游깯CINE游깯. Ya sean los estrenos de la semana, las noticias del momento, caprichos variados, sagas, recomendaciones, personajes pintorescos, pel칤culas inmirables, videoclubs rancios, mascotas come-cable, camperas de corderito, retratos con y sin perspectiva de g칠nero, cr칩nicas fueguinas, etc.

Este reporte est치 dividido en cinco partes principales. Comienzo con la descripci칩n de la fuente de datos y consideraciones generales (@sec-intro). Los an치lisis y visualizaciones se dividen en: datos num칠ricos (@sec-num), como la duraci칩n de los episodios, la cantidad de horas totales de contenido anual y las fechas de publicaci칩n; palabras (@sec-tex), a partir de los t칤tulos y descripciones de los episodios; im치genes (@sec-img), provenientes de las tapas de los cap칤tulos; y estudio de las pel칤culas analizadas (@sec-pel), como actores y directores m치s frecuentes. Finalmente, conclusiones y agradecimientos.

En la versi칩n de escritorio tienen el men칰 desplegable, a la izquierda, para moverse entre los cap칤tulos y sus secciones.

<span style='background-color:#333333'>NO HAY AN츼LISIS DEL CONTENIDO DE LOS AUDIOS. Lamentablemente (a칰n) no tengo acceso a una herramienta que me permita la transcripci칩n autom치ticamente de los episodios. [Ac치](https://twitter.com/vhgauto/status/1638011962222075904) explico un poco las opciones. Pero ni bien le encuentre la vuelta, me voy a poner manos a la obra.</span>

# Aclaraciones iniciales {#sec-intro}

::: {.column-screen-inset-right}
```{r 1_paquetes_fuentes_datos}
# A.- paquetes ------------------------------------------------------------

library(tidyverse)
library(lubridate)
library(showtext)
library(ggtext)
library(fontawesome)
library(patchwork)
library(here)
library(glue)

# B.- fuentes -------------------------------------------------------------

# browseURL("https://stackoverflow.com/questions/34522732/changing-fonts-in-ggplot2")
# font_files()
# font_add("friz", "friz.ttf")

font_add("friz_bold", here("friz/Friz Quadrata Bold.otf")) # t칤tulo
font_add_google(name = "Bebas Neue", 
                family = "bebas",
                bold.wt = 600) # resto del texto
font_add_google(name = "Titillium Web", 
                family = "titillium",
                bold.wt = 600) # subtitulo
showtext_auto()
showtext_opts(dpi = 300)

# 칤conos
# browseURL("https://albert-rapp.de/posts/ggplot2-tips/08_fonts_and_icons/08_fonts_and_icons.html")
font_add("fa-reg", here("icon/Font Awesome 5 Free-Regular-400.otf"))
font_add("fa-brands", here("icon/Font Awesome 5 Brands-Regular-400.otf"))
font_add("fa-solid", here("icon/Font Awesome 5 Free-Solid-900.otf"))

# C.- datos ---------------------------------------------------------------

# browseURL("https://www.rcharlie.com/spotifyr/index.html")

# library(spotifyr)
# 
# Sys.setenv(SPOTIFY_CLIENT_ID = 'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX')
# Sys.setenv(SPOTIFY_CLIENT_SECRET = 'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX')
# 
# access_token <- get_spotify_access_token()
# 
id_HT <- "6C4MdNWQSPhmzBlIVau30e"

# funci칩n p/descargar todos los datos de HT
# f_ep <- function(x) {
#   e <- get_show_episodes(id = id_HT,
#                          limit = 50,
#                          include_meta_info = FALSE,
#                          offset = x) |> as_tibble()
# 
#   return(e)
# }
# 
# descargo todos los datos, incluyendo las URL de las im치genes
# map(.x = seq(0, 250, 50), ~ f_ep(x = .x)) |>
#   list_rbind() |>
#   unnest(images) |>
#   write_tsv(here("data/spotify_datos_url.tsv"))
# 
# descargo todos los datos, SIN las URL de las im치genes
# map(.x = seq(0, 250, 50), ~ f_ep(x = .x)) |>
#   list_rbind() |>
#   unnest(images) |>
#   filter(width == 640) |>
#   write_tsv(here("data/spotify_datos.tsv"))

HT_all <- read_tsv(here("data/spotify_datos.tsv")) |> 
  distinct(id, .keep_all = TRUE)

# Hoy Trasnoche Diario, durante pandemia
vec_HT_diario <- HT_all %>% 
  filter(str_detect(name, pattern = "Diario")) |> 
  pull(name)

# Podcast Mat칩 Mil
vec_HT_matomil <- HT_all %>% 
  filter(str_detect(name, pattern = "Mat칩")) |> 
  pull(name)

# miscelaneo
vec_HT_misc <- HT_all %>% 
  filter(str_detect(name, pattern = "Presentamos")) |> 
  pull(name)

# todo lo que NO es Hoy Trasnoche
vec_HT_otros <- c(vec_HT_diario, vec_HT_matomil, vec_HT_misc)

# Hoy Trasnoche Diario
HT_diario <- HT_all |> 
  filter(name %in% vec_HT_diario)

# Hoy Trasnoche tradicional, de todos los "viernes"
HT_trad <- HT_all |> 
  filter(!name %in% vec_HT_otros)

# caption
icon_twitter <- "<span style='font-family:fa-brands; color:#ee4121;'>&#xf099;</span>"
icon_github <- "<span style='font-family:fa-brands; color:#ee4121;'>&#xf09b;</span>"
fuente <- "<span style='color:#ee4121;'>Datos:</span> <span style='color:#ffc10e;'>{**spotifyr**}</span>"
autor <- "<span style='color:#ee4121;'>Autor:</span> <span style='color:#ffc10e;'>**V칤ctor Gauto**</span>"
sep <- glue("<span style = 'color:#ee4121;'>**|**</span>")
usuario <- glue("<span style = 'color:#ffc10e;'>**vhgauto**</span>")

HT_caption <- glue("{fuente} {sep} {autor} {sep} {icon_github} {icon_twitter} {usuario}")

HT <- glue("<span style='font-family:friz_bold; font-weight: bold; color:#ffc10e; background-color:#ee4121'>HOY TRASNOCHE</span>")

HTD <- glue("<span style='font-family:friz_bold; font-weight: bold; color:#ffc10e; background-color:#ee4121'>HOY TRASNOCHE DIARIO</span>")

# genera la imagen del final, al fondo
# df1 <- tibble(arch = c("f_calu", "f_flor", "n_bb", "n_de", "n_hu", "n_la", "n_nc",
#                      "n_tf", "oti", "n_rh", "n_dt", "n_lb")) |> 
#   mutate(path = glue("{here()}/pic/{arch}.png")) |> 
#   mutate(x = row_number()) |> 
#   mutate(y = 0) |> 
#   mutate(ins = glue("<img src='{path}' height='40'>"))
# 
# 
# g_u <- ggplot(data = df1, aes(x, y, label = ins)) +
#   geom_richtext(label.color = NA, fill = NA) +
#   theme_void() +
#   theme(plot.background = element_rect(color = NA, fill = "black"),
#         panel.background = element_rect(color = NA, fill = "black"))
# 
# ggsave(plot = g_u,
#        filename = here("fig/u.png"),
#        width = 40,
#        height = 2,
#        units = "cm"); browseURL(here("fig/u.png"))


```
:::

<span style='background-color:#333333'>Antes que nada, seg칰n un coso que cuenta el tiempo de lectura, leer todo esto te va a llevar algo m치s de **25 minutos**. Segundo, la versi칩n TL;DR es ir directamente a las im치genes (son 13).</span>

Todos los an치lisis llevados a cabo utilizan dos grandes bases de datos. Para los episodios, la que est치 disponible en el perfil de <ht>HOY TRASNOCHE</ht> en [Spotify](https://open.spotify.com/show/6C4MdNWQSPhmzBlIVau30e); para las pel칤culas analizadas, [The Movie Database](https://www.themoviedb.org/) (TMDB) desde donde obtuve los detalles.

Para todos los gr치ficos aqu칤 exhibidos us칠 lenguaje de programaci칩n <code>R</code> (4.2.1), en el entorno de edici칩n [RStudio](https://posit.co/products/open-source/rstudio/) (2022.12.0 Build 353). Este reporte se confeccion칩 usando [Quarto](https://quarto.org/) (1.2.335).

Los datos de Spotify son accesibles mediante el paquete [<code>{spotifyr}</code>](https://www.rcharlie.com/spotifyr/index.html). Es necesario contar con acceso a la [API](https://developer.spotify.com/dashboard/applications) y generar sus credenciales. De Spotify puede obtenerse el t칤tulo del episodio, la descripci칩n, la duraci칩n, el idioma, el tipo de contenido, la fecha de publicaci칩n, el enlace para escucharlo, la direcci칩n donde se aloja la imagen que ilustra el episodio, un c칩digo de identificaci칩n, entre otros.

La lista de pel칤culas vistas se obtuvo mediante web scrapping usando [<code>{rvest}</code>](https://rvest.tidyverse.org/) y los detalles de cada una a partir de [<code>{TMDb}</code>](https://www.rdocumentation.org/packages/TMDb/versions/1.1). Es requisito poseer acceso a la API y generar la [clave](https://developers.themoviedb.org/3/getting-started/introduction) antes que nada. A partir TMDB se pueden extraer muchos datos de pel칤culas. La lista de personas involucradas en el equipo productivo, como ser guion, direcci칩n, edici칩n, sonido, efectos visuales, luces, etc. Del elenco, est치n disponibles los nombres de los actores y de sus personajes. Adem치s, los detalles t칠cnicos, como fecha de estreno, pa칤s de origen, idioma hablado, g칠nero y mucho m치s.

Las figuras fueron creadas con [<code>{ggplot2}</code>](https://ggplot2.tidyverse.org/reference/theme.html) y todo el procesamiento de datos se realiz칩 usando [<code>{tidyverse}</code>](https://www.tidyverse.org/) como herramienta fundamental. Debajo de cada figura tienen el bot칩n para desplegar el c칩digo de programaci칩n que la gener칩.

Divid칤 los episodios en tres grandes grupos: <ht>HOY TRASNOCHE</ht> propiamente dicho, el de siempre, que escuchamos (casi) todos los viernes; luego <ht>HOY TRASNOCHE DIARIO</ht>, que durante el aislamiento duro de 2020 sal칤a todos los d칤as; y los dem치s, como ser MAT칍 MIL y en los que se habl칩 de otras cosas. Este 칰ltimo grupo fue descartado de todo an치lisis, sin representar demasiado impacto general ya que son muy pocos episodios. En caso de que se especifique lo contrario, todos los an치lisis est치n hechos en base a la informaci칩n de <ht>HOY TRASNOCHE</ht> tradicional. La cosa sana.

No soy ning칰n experto en an치lisis de datos ni en programaci칩n. Soy un entusiasta de R, sigo <ht>HOY TRASNOCHE</ht> desde el primer episodio, y nunca me lo pierdo. Hacer todo esto me permiti칩 aprender un mont칩n de programaci칩n, manejo de datos, visualizaci칩n y disfrut칠 much칤simo todo el proceso.

# An치lisis de datos num칠ricos {#sec-num}

Para esta secci칩n, los datos m치s relevantes son la duraci칩n de los episodios y la fecha de publicaci칩n, extra칤dos del perfil de <ht>HOY TRASNOCHE</ht> de Spotify. Con eso es posible generar boxplots anuales de cu치nto duran los episodios (@fig-01), cantidad anual de horas de contenido ([-@fig-02]), porcentaje de publicaci칩n los viernes ([-@fig-03]), cantidad promedio de episodios por mes ([-@fig-04]) y serie consecutiva de semanas con/sin episodios ([-@fig-05]).

## Duraci칩n de los episodios {#sec-num-dur}

<!-- hacer que las im치genes abarquen m치s espacio horizontal, m치s ancho que el texto, hacia la derecha -->
<!-- https://quarto.org/docs/authoring/article-layout.html#page-column -->

::: {.column-screen-inset-right}
```{r 2_duracion_episodios}
#| fig-cap: Boxplot de la duraci칩n de los episodios, por a침o. Se muestra la cantidad de episodios y se indica la mediana anual.
#| fig-align: center

HT_dur <- HT_trad |> 
  select(fecha = release_date, duracion = duration_ms) |> 
  mutate(duracion = duracion/1000/60) |> 
  mutate(fecha = ymd(fecha)) |> 
  mutate(a침o = year(fecha)) |> 
  mutate(a침o = factor(a침o)) |> 
  group_by(a침o) |> 
  mutate(dur_media = median(duracion)) |> 
  mutate(cantidad = n()) |> 
  ungroup()

# aclaraciones
ac_01 <- tibble(x = c(26, 101), y = c(7, 7.5),
                label = c("Cantidad de episodios", 
                          "Mediana (min) de la<br>duraci칩n de los<br>episodios"),
                hjust = c(.5, 0), vjust = c(1, 1))

# flechas
fl_01 <- tibble(x = c(10, 102, 65), y = c(6.9, 7.4, 7.75), 
                xend = c(1, 93, 61), yend = c(6.95, 7.4, 7.4))

g_dur <- HT_dur |> 
  ggplot(aes(x = duracion, y = a침o)) + 
  # vertical 60 min
  geom_vline(xintercept = 60, color = "grey90", linetype = 2, linewidth = 1, 
             alpha = .5) +
  # boxplot
  geom_boxplot(show.legend = FALSE, width = .25, outlier.shape = NA,
               alpha = 1, color = "#ffc10e", fill = "#ee4121") +
  # barritas
  geom_point(show.legend = FALSE, shape = "|", size = 2, alpha = .5, 
             color = "#ffc10e", position = position_nudge(y = -.25)) +
  # tri치ngulo mediana
  geom_point(aes(x = dur_media, y = a침o), show.legend = FALSE, size = 3, 
             alpha = .8, shape = "\u25BC", color = "white", 
             position = position_nudge(y = .19)) +
  # duraci칩n mediana, por a침o
  geom_text(aes(label = round(dur_media, 0), x = dur_media), color = "white",
            nudge_y = .35, nudge_x = 0, size = 3, family = "mono") +
  # cantidad de episodios
  geom_text(aes(label = cantidad, x = 0, y = a침o), color = "grey70",
            family = "mono", vjust = 1.2, hjust = 1, size = 3) +
  # aclaraciones
  geom_richtext(data = ac_01, aes(x, y, label = label, hjust = I(hjust),
                                  vjust = I(vjust)), 
                inherit.aes = FALSE, color = "white", size = 3, 
                fontface = "italic", family = "titillium", fill = NA,
                label.color = NA) +
  # flechas
  geom_curve(data = fl_01[1:2,], aes(x, y, xend = xend, yend = yend), color = "white",
             inherit.aes = FALSE, arrow.fill = "white", curvature = .1, linewidth = .3, 
             arrow = arrow(angle = 10, length = unit(.3, "line"), type = "closed")) +
  geom_curve(data = fl_01[3,], aes(x, y, xend = xend, yend = yend), color = "white",
             inherit.aes = FALSE, arrow.fill = "white", curvature = -.1, linewidth = .3, 
             arrow = arrow(angle = 10, length = unit(.3, "line"), type = "closed")) +
  # manual
  scale_x_continuous(breaks = seq(0, 120, 10),
                     limits = c(0, 120),
                     expand = c(0, 0)) +
  scale_y_discrete(expand = c(0, 0)) +
  scale_fill_brewer(palette = "Dark2") +
  # ejes
  labs(x = "Duraci칩n (min)", y = NULL,
       title = "CADA A칌O HAY M츼S<br><span style = 'color:#ffc10e;'>**HOY TRASNOCHE**</span>",
       subtitle = "Durante los primeros cuatro a침os, la mediana de la duraci칩n de<br>los episodios
       no superaba la hora. A partir de <span style = 'color:#ffc10e;'>2021</span> los episodios<br>comenzaron a cruzar la 
       marca de los <span style = 'color:#ee4121;'>60 minutos</span>.",
       caption = HT_caption) +
  coord_cartesian(ylim = c(.5, 7.5), clip = "off") +
  theme_minimal() +
  theme(aspect.ratio = 1,
        axis.text = element_text(color = "grey90"),
        axis.text.y = element_text(size = 22, vjust = 0, family = "bebas",
                                   color = "grey30"),
        axis.text.x = element_text(family = "mono", size = 10),
        axis.title.x = element_text(margin = margin(8, 0, 0, 0), size = 15,
                                    color = "grey90", family = "bebas"),
        panel.grid.minor = element_blank(),
        panel.grid.major = element_line(color = "grey10", linewidth = .1),
        panel.background = element_rect(fill = "black", color = NA),
        plot.background = element_rect(fill = "black", color = "grey30"),
        plot.title = element_markdown(size = 27, family = "friz_bold",
                                      color = "#ee4121"),
        plot.title.position = "plot",
        plot.subtitle = element_markdown(color = "white", size = 12,
                                         family = "titillium",
                                         margin = margin(4, 0, 10, 0)),
        plot.caption = element_markdown(hjust = .5, family = "titillium",
                                        margin = margin(15, 0, 0, 0), size = 9),
        plot.caption.position = "plot",
        plot.margin = margin(5, 25, 5, 5))

ggsave(plot = g_dur,
       filename = here("fig/HT_01.png"),
       width = 13,
       height = 16.7,
       units = "cm",
       dpi = 300)

# texto
HT_d <- HT_trad |> 
  select(fecha = release_date, duracion = duration_ms) |> 
  mutate(duracion = duracion/1000/60) |> 
  mutate(fecha = ymd(fecha))

ep_2017 <- HT_dur |> 
  filter(a침o == 2017) |> 
  distinct(cantidad) |> 
  pull()

med_2017 <- HT_dur |> 
  filter(a침o == 2017) |> 
  distinct(dur_media) |> 
  pull()

med_2023 <- HT_dur |> 
  filter(a침o == 2023) |> 
  distinct(dur_media) |> 
  pull()

ep_corto <- HT_trad |> 
  mutate(fecha = release_date, duracion = duration_ms) |> 
  mutate(duracion = duracion/1000/60) |> 
  mutate(fecha = ymd(fecha)) |> 
  filter(duracion == min(duracion))

ep_largo <- HT_trad |> 
  mutate(fecha = release_date, duracion = duration_ms) |> 
  mutate(duracion = duracion/1000/60) |> 
  mutate(fecha = ymd(fecha)) |> 
  filter(duracion == max(duracion))

```
:::

::: {.column-screen-inset-right}
![Boxplot de la duraci칩n de los episodios, por a침o. Se muestra la distribui칩n (l칤neas verticales amarillas) de episodios, la cantidad y la mediana anual.](fig/HT_01.png){#fig-01 fig-align="center"}
:::

Las peque침as l칤neas verticales amarillas en cada a침o indican las duraciones individuales de los episodios. La caja del boxplot contiene el 50% de todos los datos, y la l칤nea que lo divide marca la mediana de la distribuci칩n de tiempos. La mediana indica el valor central de las duraciones. Por ejemplo, para 2019, la mitad de todos los episodios dur칩 menos de 53 minutos, y la otra mitad dur칩 m치s de 53 minutos.

La @fig-01 muestra la evoluci칩n de la duraci칩n de los episodios, a침o a a침o. Comenzando en 2017, con solo `r ep_2017` programas y `r round(med_2017)` minutos de extensi칩n, hasta 2023 con casi una hora y media (`r round(med_2023)`), aunque a칰n con pocas emisiones. Me parece relevante mostrar la marca (vertical a trazos) de los 60 minutos, donde queda claro que durante los primeros cuatro a침os de <ht>HOY TRASNOCHE</ht> la mediana era sub-1 hora. A partir de 2021 se super칩 esa marca, y desde entonces sigue en aumento.

El cap칤tulo m치s corto es de `r round(ep_corto$duracion)` minutos, titulado justamente [`r ep_corto$name`](https://open.spotify.com/episode/2BkTi0k3q1JtcBdl9Uua5L), del `r format(ep_corto$fecha, "%d de %B de %Y")`. Con `r floor((ep_largo$duracion)/60)` hora y `r floor(((ep_largo$duracion)/60 - floor((ep_largo$duracion)/60))*60)` minutos, el cap칤tulo m치s largo es [`r ep_largo$name`](https://open.spotify.com/episode/6ig7lNaKK13LJlrGBbE4No), publicado el `r format(ep_largo$fecha, "%d de %B de %Y")`.


## Cantidad de contenido {#sec-num-tot}

::: {.column-screen-inset-right}
```{r 3_cantidad_contenido}
# 2.- columnas, duraci칩n total anual --------------------------------------

HT_dur_tot <- HT_trad |> 
  select(fecha = release_date, duracion = duration_ms) |> 
  mutate(duracion = duracion/1000/60) |> 
  group_by(a침o = year(fecha)) |> 
  summarise(dur_tot = sum(duracion),
            dur_prom = mean(duracion),
            cantidad = n()) |> 
  mutate(dur_tot = dur_tot/60) |> 
  mutate(dur_hora = (dur_prom - dur_prom %% 60)/60) |> 
  mutate(dur_min = dur_prom %% 60 |> round(0)) |> 
  mutate(dur_label = if_else(dur_hora == 0,
                             glue("**{dur_min}**m"),
                             glue("**{dur_hora}**h **{dur_min}**m"))) |> 
  ungroup()

etq_dia <- tibble(x = 2023.5, y = c(24, 48), label = c("1 d칤a", "2 d칤as"))

# aclaraci칩n
ac_02 <- tibble(x = c(2017.2, 2017.6, 2017.5), y = c(40, 30, 8),
                label = c("Suma total<br>acumulada",
                          "Duraci칩n promedio<br>de cada episodio",
                          "Cantidad<br>de episodios"),
                hjust = c(1, 1, 0), vjust = 1)

# flecha
fl_02 <- tibble(x = c(2017, 2017.55, 2018.1), y = c(37, 29.5, 5.2),
                xend = c(2017.5, 2017.8, 2017.95), yend = c(36, 31.7, 2.5))

g_tot <- ggplot(data = HT_dur_tot, aes(x = a침o, y = dur_tot)) +
  # horizontales 1 d칤a y 2 d칤as
  geom_hline(yintercept = c(24, 48), color = "grey90", linetype = 2, alpha = .5,
             linewidth = 1) +
  # etiqueta 1 d칤a y 2 d칤as
  geom_text(data = etq_dia, aes(x, y, label = label), inherit.aes = FALSE, 
            color = "grey90", family = "titillium", nudge_y = 1, hjust = 1,
            alpha = .5) +
  # columna
  geom_col(color = NA, fill = "#ee4121") +
  # total anual
  geom_text(aes(label = glue("{round(dur_tot, 0)}h")), color = "#ffc10e", 
            nudge_y = .5, nudge_x = -.4, size = 10, family = "bebas",
            vjust = 0, hjust = 0) +
  # promedio duraci칩n de episodio por a침o
  geom_richtext(aes(label = dur_label, x = a침o), color = "black", fill = NA,
                nudge_y = -2.5, nudge_x = -.4, size = 4, family = "titillium",
                vjust = 0, 
                hjust = 0, label.size = NA, label.padding = unit(.1, "line")) +
  # cantidad de episodios por a침o
  geom_richtext(aes(label = glue("{cantidad}"), y = 1), color = "grey90", 
                fill = NA, nudge_y = 0, nudge_x = -.4, size = 4, 
                family = "mono", vjust = 0, hjust = 0, label.size = NA, 
                label.padding = unit(.1, "line")) +
  # aclaraciones
  geom_richtext(data = ac_02, aes(x, y, label = label, hjust = I(hjust), 
                                  vjust = I(vjust)),  inherit.aes = FALSE, 
                color = "white", size = 3, fontface = "italic",
                family = "titillium", fill = NA, label.color = NA) +
  # flechas
  geom_curve(data = fl_02[1:2,], aes(x, y, xend = xend, yend = yend), color = "white",
             inherit.aes = FALSE, arrow.fill = "white", curvature = +.1, linewidth = .3, 
             arrow = arrow(angle = 10, length = unit(.3, "line"), type = "closed")) +
  geom_curve(data = fl_02[3,], aes(x, y, xend = xend, yend = yend), color = "white",
             inherit.aes = FALSE, arrow.fill = "white", curvature = -.1, linewidth = .3, 
             arrow = arrow(angle = 10, length = unit(.3, "line"), type = "closed")) +
  # flecha t칤tulo 48 horas
  geom_curve(x = 2020.4, y = 50, xend = 2021.5, yend = 45, inherit.aes = FALSE,
             color = "white", arrow.fill = "white", curvature = +.1,
             linewidth = .3, arrow = arrow(angle = 10, length = unit(.3, "line"),
                                           type = "closed")) +
  # manual
  scale_x_continuous(breaks = seq(2017, 2023, 1), 
                     limits = c(2016.5, 2023.5),
                     expand = c(0, 0)) +
  scale_y_continuous(limits = c(0, 49),
                     expand = c(0, 0)) +
  # ejes
  labs(x = NULL, y = NULL,
       title = "EN TODO 2022 <span style = 'color:#ffc10e;'>FLOR</span> 
       Y <span style = 'color:#ffc10e;'>CALU</span><br>
       TRABAJARON <span style = 'color:#ffc10e;'>2 D칈AS</span>",
       subtitle = "Entre <span style = 'color:#ffc10e;'>2018-2021</span>, 
       la suma de la duraci칩n total anual se mantuvo entre<br>las 
       <span style = 'color:#ee4121;'>30-39</span> horas. En 
       <span style = 'color:#ffc10e;'>2022</span> alcanz칩 las 
       <span style = 'color:#ee4121;'>48 horas</span>.",
       caption = HT_caption) +
  coord_cartesian(clip = "off") +
  theme_minimal() +
  theme(aspect.ratio = 1,
        axis.text.y = element_blank(),
        axis.text.x = element_text(family = "bebas", size = 17, color = "grey30",
                                   margin = margin(4, 0, 10, 0)),
        panel.grid.major.y = element_blank(),
        panel.grid.minor.y = element_blank(),
        panel.grid = element_blank(),
        panel.background = element_rect(fill = "black", color = NA),
        plot.background = element_rect(fill = "black", color = "grey30"),
        plot.title = element_markdown(size = 23, family = "friz_bold",
                                      color = "#ee4121"),
        plot.title.position = "plot",
        plot.subtitle = element_markdown(color = "white", size = 12,
                                         family = "titillium",
                                         margin = margin(4, 0, 10, 0)),
        plot.caption = element_markdown(hjust = .5, family = "titillium",
                                        margin = margin(15, 0, 0, 0), size = 9),
        plot.caption.position = "plot",
        plot.margin = margin(6, 10, 5, 10))

ggsave(plot = g_tot,
       filename = here("fig/HT_02.png"),
       width = 13.4,
       height = 18,
       units = "cm",
       dpi = 300)

# texto
tot_2022 <- HT_dur_tot |> 
  filter(a침o == 2022) |> 
  pull(dur_tot)

tot_2023 <- HT_dur_tot |> 
  filter(a침o == 2023) |> 
  pull(dur_tot)

ep_2022 <- HT_dur_tot |> 
  filter(a침o == 2022) |> 
  pull(cantidad)

ep_2023 <- HT_dur_tot |> 
  filter(a침o == 2023) |> 
  pull(cantidad)

prom_2022 <- HT_dur_tot |> 
  filter(a침o == 2022) |> 
  mutate(d = glue("{dur_hora}h {dur_min}m")) |> 
  pull(d)

```
:::

::: {.column-screen-inset-right}
![Suma total de la duraci칩n de los episodios, por a침o. En la base de cada columna se indica la cantidad de episodios emitidos en el a침o indicado; y en la parte superior, las duraciones promedio de cada episodio.](fig/HT_02.png){#fig-02 fig-align="center"}
:::

Las columnas de la @fig-02 representan la suma total de las duraciones de todos los episodios emitidos en ese a침o. Se muestran en l칤neas horizontales a trazos las marcas de 24 horas y 48 horas.

El primer a침o, con poco m치s de 20 episodios, se alcanz칩 las 18 horas de contenido. El promedio por episodio fue de 52 minutos. Entre 2018 y 2021 generaron entre 30 y casi 40 horas anuales. El a침o r칠cord es 2022, con `r round(tot_2022)` horas de contenido, `r ep_2022` episodios en total y `r prom_2022` de duraci칩n promedio. N칩tese que los valores en negro en la parte superior de las columnas son promedios, no confundir con las medianas (valores en color blanco) de la @fig-01 en los boxplots.

En lo poco que va de 2023, con apenas `r ep_2023` cap칤tulos, ya se alcanz칩 las `r round(tot_2023)` horas totales.

Se mantiene la tendencia vista en la @fig-01. Con el progresar de los a침os, hay m치s y m치s contenido.

## Publicaciones durante los viernes {#sec-num-vie}

::: {.column-screen-inset-right}
```{r 4_publicacion_viernes}
# 3.- columnas, viernes ---------------------------------------------------

HT_viernes <- HT_trad |> 
  select(fecha = release_date) |> 
  mutate(fecha = ymd(fecha)) |> 
  mutate(dia = weekdays(fecha)) |> 
  group_by(a침o = year(fecha)) |> 
  count(dia) |> 
  mutate(dia = str_to_sentence(dia)) |> 
  mutate(dia = fct_infreq(dia)) |> 
  mutate(dia = fct_rev(dia)) |> 
  mutate(n_prop = n/sum(n)*100) |> 
  ungroup() |> 
  filter(dia == "Viernes") |> 
  mutate(a침o = factor(a침o))

HT_jueves <- HT_trad |> 
  select(fecha = release_date) |> 
  mutate(fecha = ymd(fecha)) |> 
  mutate(dia = weekdays(fecha)) |> 
  group_by(a침o = year(fecha)) |> 
  count(dia) |> 
  mutate(dia = str_to_sentence(dia)) |> 
  mutate(dia = fct_infreq(dia)) |> 
  mutate(dia = fct_rev(dia)) |> 
  mutate(n_prop = n/sum(n)*100) |> 
  filter(dia != "Viernes") |> 
  ungroup() |> 
  slice_max(n, n = 1)

HT_total_a침o <- HT_trad |> 
  select(fecha = release_date) |> 
  mutate(fecha = ymd(fecha)) |> 
  mutate(dia = weekdays(fecha)) |> 
  group_by(a침o = year(fecha)) |> 
  summarise(tot_ep = n())

HT_prop_vier <- HT_trad |> 
  select(fecha = release_date) |> 
  mutate(fecha = ymd(fecha)) |> 
  mutate(dia = weekdays(fecha)) |> 
  group_by(a침o = year(fecha)) |> 
  count(dia) |> 
  ungroup() |> 
  filter(dia == "viernes") |> 
  left_join(HT_total_a침o, by = "a침o") |> 
  select(a침o, tot_vier = n, tot_ep) |> 
  mutate(a침o = factor(a침o)) |> 
  left_join(HT_viernes, by = "a침o") |> 
  select(-dia, -n, vier_prop = n_prop)

# aclaraciones
ac_03 <- tibble(x = c(85, 40, 40), y = c(7.7, 7.45, 6.85),
                label = c("Porcentaje de episodios<br>publicados los viernes",
                          "Episodios publicados<br>los viernes",
                          "Episodios totales"),
                hjust = 1, vjust = 1)

# flechas
fl_03 <- tibble(x = c(41, 41, 86), y = c(7.3, 6.7, 7.3),
                xend = c(47, 47.2, 92), yend = c(7.2, 6.8, 7.05))

g_viernes <-  ggplot(data = HT_viernes, aes(x = n_prop, y = a침o)) +
  # vertical 100%
  geom_vline(xintercept = 100, color = "grey90", linetype = 2, alpha = .5,
             linewidth = 1) +
  # columna
  geom_col(fill = "#ee4121", color = NA, width = .8) +
  # porcentajes
  geom_text(aes(label = glue("{round(n_prop, 0)}%")), color = "black",
            family = "bebas", size = 9.1, hjust = 1, vjust = 1, nudge_x = 0,
            nudge_y = -.05, fontface = "bold") +
  # jueves, 2020
  geom_richtext(x = 40.5, y = factor(2020), 
            label = glue("En 2020 el <span style = 'color:#ffc10e;'>{round(HT_jueves$n_prop, 0)}%</span> de los episodios<br>
                         fueron publicados los <span style = 'color:#ffc10e;'>jueves</span>"), inherit.aes = FALSE, hjust = 0,
            color = "white", fill = NA, label.color = NA, family = "titillium",
            vjust = .3) +
  # proporciones viernes por a침o
  geom_richtext(data = HT_prop_vier, inherit.aes = FALSE,
                aes(x = vier_prop/2, y = a침o, label = glue("{tot_vier}<br>{tot_ep}")),
                color = "grey80", fill = NA, label.color = NA, family = "mono",
                fontface = "bold") +
  # l칤nea horizontal entre proporci칩n
  geom_richtext(data = HT_prop_vier, inherit.aes = FALSE,
                aes(x = vier_prop/2, y = a침o, label = glue("_")), nudge_y = .2,
                color = "grey80", fill = NA, label.color = NA, family = "mono",
                size = 10) +
  # aclaraciones
  geom_richtext(data = ac_03, aes(x, y, label = label, hjust = I(hjust), 
                                  vjust = I(vjust)),  inherit.aes = FALSE, 
                color = "white", size = 3, fontface = "italic",
                family = "titillium", fill = NA, label.color = NA) +
  # flechas
  geom_curve(data = fl_03[c(1, 3),], aes(x, y, xend = xend, yend = yend), color = "white",
             inherit.aes = FALSE, arrow.fill = "white", curvature = -.1, linewidth = .3, 
             arrow = arrow(angle = 10, length = unit(.3, "line"), type = "closed")) +
  geom_curve(data = fl_03[2,], aes(x, y, xend = xend, yend = yend), color = "white",
             inherit.aes = FALSE, arrow.fill = "white", curvature = +.1, linewidth = .3, 
             arrow = arrow(angle = 10, length = unit(.3, "line"), type = "closed")) +
  # manual
  scale_x_continuous(limits = c(0, 110),
                     breaks = 100,
                     labels = "100%",
                     expand = c(0, 0)) +
  # ejes
  labs(x = NULL, y = NULL,
       title = "COMO TODOS LOS <span style = 'color:#ffc10e;'>VIERNES</span>,<br>
       UN NUEVO EPISODIO DE<br><span style = 'color:#ffc10e;'>HOY TRASNOCHE</span>",
       subtitle = "Casi todos los episodios se publican los 
       <span style = 'color:#ee4121;'>viernes</span>, excepto
       durante <span style = 'color:#ffc10e;'>2020</span>.<br>Desde 
       <span style = 'color:#ffc10e;'>2022</span> los episodios se publican
       exclusivamente los <span style = 'color:#ee4121;'>viernes</span>.",
       caption = glue("{fuente} {sep} {autor} {sep} {icon_github} {icon_twitter} {usuario}")) +
  coord_cartesian(clip = "off", ylim = c(1, 7)) +
  theme_minimal() +
  theme(aspect.ratio = 1,
        axis.text = element_text(color = "grey90"),
        axis.text.y = element_text(size = 22, vjust = .5, family = "bebas",
                                   color = "grey30"),
        axis.text.x = element_text(family = "mono", size = 10,
                                   color = alpha("grey90", .3),
                                   margin = margin(4, 0, 10, 0)),
        panel.grid.major.y = element_blank(),
        panel.grid.minor.y = element_blank(),
        panel.grid = element_blank(),
        panel.background = element_rect(fill = "black", color = NA),
        plot.background = element_rect(fill = "black", color = "grey30"),
        plot.title = element_markdown(size = 24, family = "friz_bold",
                                      color = "#ee4121"),
        plot.title.position = "plot",
        plot.subtitle = element_markdown(color = "white", size = 12,
                                         family = "titillium",
                                         margin = margin(4, 0, 10, 0)),
        plot.caption = element_markdown(hjust = .5, family = "titillium",
                                        margin = margin(5, 0, 0, 0), size = 9),
        plot.caption.position = "plot",
        plot.margin = margin(10, 5, 5, 10))

ggsave(plot = g_viernes,
       filename = here("fig/HT_03.png"),
       width = 14,
       height = 18,
       units = "cm",
       dpi = 300)

# texto
jueves_2020 <- HT_jueves |> 
  pull(n_prop)

```
:::

::: {.column-screen-inset-right}
![Las columnas muestran el porcentaje anual de publicaci칩n los viernes. Se muestra la cantidad de episodios anuales y cu치ntos de estos se publicaron un viernes.](fig/HT_03.png){#fig-03 fig-align="center"}
:::

A diferencia de las secciones previas (@sec-num-dur y [-@sec-num-tot]) donde se analizaron las duraciones de los episodios, en esta secci칩n se habla de las fechas de publicaci칩n, y se confirma que: si es viernes, hay <ht>HOY TRASNOCHE</ht>, digamos. No quiere decir que salga todos los viernes, eso se analiza en la @sec-num-pala. Significa que cada vez que hubo un nuevo episodio, muy probablemente fue viernes.

Con excepci칩n de 2020, todos los a침os al menos el 90% de los cap칤tulos se publican los viernes. En 2022 y lo que va de 2023, la totalidad de los episodios estuvieron disponibles los viernes. El verdadero TGIF.

Durante 2020, fue el jueves el d칤a m치s frecuente, con el `r round(jueves_2020)`% de los cap칤tulos disponibles ese d칤a.

## Distribuci칩n de episodios por mes {#sec-num-mes}

::: {.column-screen-inset-right}
```{r 5_frecuencia_mes}
# 4.- columna/heatmap -----------------------------------------------------

ac_04 <- tibble(x = c(5.1, 2023.5, 2022.8), y = c(11.8, 4, 8),
                label = c("Promedio de<br>episodios<br>publicados",
                          "3 meses<br>seguidos sin<br>episodios",
                          glue("{length(vec_HT_diario)} episodios de<br>Hoy Trasnoche Diario")),
                hjust = 0, vjust = 1)

fl_04 <- tibble(x = c(4.5, 2023.5, 2023.5), y = c(10.6, 3.5, 7.2),
                xend = c(3.8, 2021.3, 2020.2), yend = c(10.2, 2, 4))

# datos IZQUIERDA
HT_mes <- HT_all |> 
  mutate(fecha = ymd(release_date)) |> 
  select(fecha, name) |> 
  mutate(estado = if_else(name %in% vec_HT_diario,
                          "diario",
                          "trad")) |> 
  select(-name) |> 
  mutate(a침o = year(fecha),
         mes = month(fecha)) |> 
  mutate(episodio = 1) |> 
  group_by(mes, a침o, estado) |> 
  summarise(tot = sum(episodio), .groups = "drop") |> 
  group_by(mes, estado) |> 
  summarise(prom = mean(tot), .groups = "drop") |> 
  arrange(mes) |> 
  mutate(mes_label = ymd(glue("2020-{mes}-01")) |> format("%b")) |> 
  mutate(mes_label = str_remove(mes_label, "\\.") |> str_to_sentence()) |> 
  mutate(mes_label = fct_reorder(mes_label, mes)) |> 
  filter(estado == "trad") |>
  mutate(prom_label = round(prom, digits = 2) |> 
           format(x = _, nsmall = 2) |> 
           str_replace(string = _, "\\.", ","))

# plot IZQUIERDA
g_izq <- ggplot(data = HT_mes, aes(x = prom, y = mes_label, fill = estado)) +
  # verticales 25 y 50
  geom_segment(data = tibble(x = c(2, 3, 4), xend = c(2, 3, 4),
                             y = c(.5, .5, .5), yend = c(12.3, 12.3, 12.3)),
               aes(x , y, xend = xend, yend = yend),
               inherit.aes = FALSE, color = "grey90", linetype = 2, alpha = .5,
               linewidth = 1) +
  # columna
  geom_col(position = position_stack(), show.legend = FALSE, width = .7) +
  # promedio mensual
  geom_text(aes(label = prom_label), position = position_stack(vjust = 0),
            color = "black", family = "mono",  size = 4, hjust = -.05, vjust = -.2) +
  # aclaraci칩n promedio
  geom_richtext(data = ac_04[1,], aes(x, y, label = label, hjust = I(hjust), 
                                  vjust = I(vjust)),  inherit.aes = FALSE, 
                color = "white", size = 3, fontface = "italic",
                family = "titillium", fill = "black", label.color = NA) +
  # flecha suma total acumulada
  geom_curve(data = fl_04[1,], aes(x, y, xend = xend, yend = yend), color = "white",
             inherit.aes = FALSE, arrow.fill = "white", curvature = .1, linewidth = .3, 
             arrow = arrow(angle = 10, length = unit(.3, "line"), type = "closed")) +
  # manual
  scale_x_continuous(trans = "reverse",
                     breaks = c(2, 3, 4),
                     limits = c(5.1, 0), # orden inverso !!!
                     expand = c(0, 0)) +
  scale_y_discrete(position = "right", expand = c(0, 0)) +
  scale_fill_manual(values = c("#ee4121"),
                    labels = c("Hoy Trasnoche Diario"),
                    name = NULL) +
  coord_cartesian(clip = "off", ylim = c(.5, 12.5)) +
  # ejes
  labs(y = NULL, x = NULL) +
  theme_minimal() +
  theme(aspect.ratio = 2,
        axis.text = element_text(color = "grey90"),
        axis.text.y.right = element_text(size = 22, vjust = .5, family = "bebas",
                                         color = "grey90", hjust = .5,
                                         margin = margin(0, 0, 0, 7)),
        axis.text.x = element_text(family = "mono", size = 13,
                                   color = alpha("grey90", .5),
                                   margin = margin(4, 0, 10, 0)),
        panel.grid.major.y = element_blank(),
        panel.grid.minor.y = element_blank(),
        panel.grid = element_blank(),
        panel.background = element_rect(fill = "black", color = NA),
        plot.background = element_rect(fill = "black", color = NA),
        plot.margin = margin(5, 0, 5, 0))

# datos DERECHA
HT_tile2 <- HT_all |> 
  filter(!name %in% c(vec_HT_matomil, vec_HT_misc)) |> 
  mutate(fecha = release_date |> ymd()) |> 
  select(fecha) |> 
  mutate(mes = month(fecha)) |> 
  mutate(a침o = year(fecha)) |> 
  mutate(episodio = 1) |> 
  group_by(a침o, mes) |> 
  summarise(total = sum(episodio), .groups = "drop") |> 
  mutate(mes_a침o = glue("{mes}_{a침o}"))

HT_falta <- expand(HT_tile2, a침o, mes) |> 
  mutate(mes_a침o = glue("{mes}_{a침o}"))

mes_a침o_HT <- HT_all |> 
  filter(!name %in% c(vec_HT_matomil, vec_HT_misc)) |> 
  mutate(fecha = release_date |> ymd()) |> 
  select(fecha) |> 
  mutate(mes = month(fecha)) |> 
  mutate(a침o = year(fecha)) |> 
  mutate(mes_a침o = glue("{mes}_{a침o}")) |> 
  distinct(mes_a침o) |> 
  pull()

HT_tile_negro <- HT_falta |> 
  filter(!mes_a침o %in% mes_a침o_HT) |> 
  mutate(total = 0)

meses_orden <- c("Ene", "Feb", "Mar", "Abr", "May", "Jun", "Jul", "Ago", "Sep",
                 "Oct", "Nov", "Dic")

mes_actual <- HT_all |> 
  mutate(fecha = ymd(release_date)) |> 
  slice_max(fecha) |> 
  pull(fecha) |> 
  month()

HT_tile <- bind_rows(HT_tile2, HT_tile_negro) |> 
  select(-mes_a침o) |> 
  mutate(estado = case_when(total <= 3 & total != 0 ~ "Menos de 4",
                            total > 3 & total <= 10 ~ "Entre 4 y 6",
                            total > 10 ~ "M치s de 10",
                            TRUE ~ "Sin episodios")) |>
  arrange(total) |>
  mutate(estado = case_when(a침o == 2017 & mes <= 3 ~ NA,
                            a침o == 2023 & mes > mes_actual ~ NA,
                            TRUE ~ estado)) |> 
  mutate(estado = fct_inorder(estado)) |> 
  mutate(fecha_X = ymd(glue("{a침o}-{mes}-01"))) |> 
  mutate(mes = format(fecha_X, "%b")) |> 
  mutate(mes = str_replace(mes, "\\.", "")) |> 
  mutate(mes = str_to_sentence(mes)) |> 
  mutate(mes = factor(mes, levels = meses_orden)) |> 
  filter(!is.na(estado))

# plot DERECHA
g_der <- ggplot(data = HT_tile, aes(x = a침o, y = mes, fill = estado)) +
  # tile
  geom_tile(color = "black", show.legend = TRUE, linewidth = 2) +
  # aclaraciones
  geom_richtext(data = ac_04[2:3,], aes(x, y, label = label, hjust = I(hjust), 
                                  vjust = I(vjust)),  inherit.aes = FALSE, 
                color = "white", size = 3, fontface = "italic",
                family = "titillium", fill = NA, label.color = NA) +
  # flechas
  geom_curve(data = fl_04[2:3,], aes(x, y, xend = xend, yend = yend), color = "grey70",
             inherit.aes = FALSE, arrow.fill = "grey70", curvature = -.1, linewidth = .3, 
             arrow = arrow(angle = 10, length = unit(.3, "line"), type = "closed")) +
  # manual
  scale_x_continuous(breaks = 2017:2023,
                     labels = paste0("'", 17:23),
                     expand = c(0, 0)) +
  scale_fill_manual(values = c("grey30", "#ee4121", "#ffc10e", "white"),
                    na.value = "black",
                    name = "Hoy Trasnoche\nDiario +\nHoy Trasnoche") +
  coord_cartesian(clip = "off") +
  labs(y = NULL, x = NULL) +
  guides(fill = guide_legend(reverse = TRUE)) +
  theme_minimal() +
  theme(aspect.ratio = 2,
        legend.position = c(1.15, .85),
        legend.background = element_rect(color = "grey30", fill = NA, linetype = 2,
                                         linewidth = .2),
        legend.key.size = unit(1, "line"),
        legend.text = element_text(color = "white", family = "titillium",
                                   size = 8),
        legend.title = element_text(color = "white", family = "titillium",
                                    size = 9),
        axis.text.y = element_blank(),
        axis.text.x = element_text(family = "bebas", size = 18,
                                   color = alpha("grey30", 1),
                                   margin = margin(4, 0, 10, 0)),
        panel.grid.major.y = element_blank(),
        panel.grid.minor.y = element_blank(),
        panel.grid = element_blank(),
        panel.background = element_rect(fill = "black", color = NA),
        plot.background = element_rect(fill = "black", color = NA),
        plot.margin = margin(5, 65, 5, 0))

# PLOT COMPUESTA
g_comp <- g_izq + g_der &
  plot_annotation(title = "EN SU MAYOR칈A, TENEMOS AL<br>MENOS 
                  <span style='color:#ffc10e;'>3 EPISODIOS MENSUALES</span>",
                  subtitle = "En <span style='color:#ffc10e;'>enero</span> y 
                  <span style='color:#ffc10e;'>febrero</span> se dan los promedios 
                  m치s bajos. El m치ximo ocurre en mayo, con 
                  <span style='color:#ee4121;'>3,83</span> <br>episodios. En 2020,
                  entre marzo y mayo, <span style='color:#ffc10e;'>durante el 
                  aislamiento</span>, se produjeron la mayor<br>cantidad de 
                  episodios por mes, gracias a <span style='color:#ee4121;'>Hoy 
                  Trasnoche Diario</span>.",
                  caption = glue("{fuente} {sep} {autor} {sep} {icon_github} {icon_twitter} {usuario}"),
                  theme = theme(
                    plot.background = element_rect(color = "grey30",
                                                   fill = "black"),
                    plot.title.position = "plot",
                    plot.title = element_markdown(size = 23, family = "friz_bold",
                                                  color = "#ee4121"),
                    plot.subtitle = element_markdown(color = "white", size = 12,
                                                     family = "titillium",
                                                     margin = margin(2, 0, 2, 0)),
                    plot.caption = element_markdown(hjust = .5, family = "titillium",
                                                    margin = margin(1, 0, 0, 0), size = 9),
                    plot.caption.position = "plot"))

ggsave(plot = g_comp,
       filename = here("fig/HT_04.png"),
       width = 17,
       height = 18,
       units = "cm",
       dpi = 300)

# texto

promedio_mayo <- HT_mes |> 
  filter(mes_label == "May") |> 
  pull(prom_label)

p_mensual <- HT_tile |> 
  mutate(mayor_3 = total >= 3) |> 
  count(mayor_3) |> 
  mutate(p = round(n/sum(n)*100)) |> 
  pull(p)

```
:::

::: {.column-screen-inset-right}
![Las barras horizontales de la izquierda indican la cantidad promedio de episodios por mes indicado. A la derecha se muestra un *heat-map* con la cantidad de episodios por mes y a침o.](fig/HT_04.png){#fig-04 fig-align="center"}
:::

Con la fecha de publicaci칩n es posible analizar la frecuencia y la suma acumulada de episodios por mes.

A la izquierda de la @fig-04 se muestran la cantidad promedio de episodios publicados por mes. A comienzo de a침o, entre enero y abril, se alcanzan como m치ximo a producir 3 episodios mensuales. En mayo se alcanza la m치xima producci칩n, de `r promedio_mayo`.

El lado derecho de la figura muestra la cantidad total de episodios publicados en cada mes de cada a침o. En gris se indica la ausencia total de cap칤tulos. N칩tese la secuencia de tres meses seguidos sin episodios a principios de 2021 (m치s informaci칩n en la @sec-num-pala). En el primer a침o de vida de <ht>HOY TRASNOCHE</ht> estuvimos 2 meses sin actividad, entre agosto y septiembre de 2017.

En blanco se se침alan los meses con m치s de 10 episodios, que corresponden a las ediciones de <ht>HOY TRASNOCHE DIARIO</ht>. Durante marzo, abril y mayo de 2020, en el per칤odo de aislamiento m치s estricto, tuvimos `r nrow(HT_diario)` episodios en total. Claramente la mayor densidad de episodios.

Desde abril de 2021 tenemos al menos un episodio todos los meses, sin falta. El 칰ltimo mes entero sin actividad fue marzo de 2021. En el `r p_mensual[2]`% de todos los meses tuvimos **al menos 3** episodios.

## Serie consecutiva de episodios semanales {#sec-num-pala}

::: {.column-screen-inset-right}
```{r 6_frecuencia_semanal_escalera}
# 5.- step, pala v palan't ------------------------------------------------

HT_sin_actividad <- HT_trad |> 
  mutate(fecha1 = release_date |> ymd()) |> 
  select(fecha1) |> 
  mutate(fecha2 = lag(fecha1)) |> 
  mutate(delta_dia = fecha2 - fecha1) |> 
  arrange(desc(delta_dia)) |> 
  slice_max(delta_dia, n = 2) |> 
  mutate(delta_semana = round(as.numeric(delta_dia)/7 - 1, 0)) |> 
  mutate(fecha1_etq = format(fecha1, "%d %b %y") %>% str_remove(., "\\.")) |> 
  mutate(fecha2_etq = format(fecha2, "%d %b %y") %>% str_remove(., "\\.")) |> 
  mutate(fecha1_etq = toupper(fecha1_etq),
         fecha2_etq = toupper(fecha2_etq))

HT_s1 <- HT_sin_actividad[1, ]
HT_s2 <- HT_sin_actividad[2, ]

# 15 semanas seguidas SIN episodios, 2020-12-31 al 2021-04-23, 113 d칤as
# 12 semanas seguidas SIN episodios, 2017-07-14 al 2017-10-13, 91 d칤as

# PALAN'T
acla_s1 <- glue("<img src='{here('pic/palant.png')}' width='40' /><br>
                {HT_s1$delta_semana} semanas<br>
               {HT_s1$fecha1_etq} - {HT_s1$fecha2_etq}")
acla_s2 <- glue("<img src='{here('pic/palant.png')}' width='40' /><br>
                {HT_s2$delta_semana} semanas<br>
               {HT_s2$fecha1_etq} - {HT_s2$fecha2_etq}")

# secuencia agarrando la pala
HT_semana <- HT_trad |>
  mutate(fecha = release_date |> ymd()) |>
  select(fecha) |>
  arrange(fecha) |>
  mutate(semana = week(fecha)) |>
  mutate(episodio = 1)

HT_semana2 <- HT_semana |> 
  mutate(a침o = year(fecha)) |> 
  select(-fecha, -episodio) |> 
  distinct() |> 
  mutate(episodio = 1)

ordenado <- tibble(fecha = seq.Date(from = ymd(20170417), ymd(20230217), "1 day")) |>
  mutate(semana = week(fecha)) |>
  mutate(a침o = year(fecha)) |>
  distinct(semana, a침o, .keep_all = TRUE) |>
  select(-fecha) |> 
  full_join(HT_semana2, by = join_by(a침o, semana)) |>
  arrange(a침o, semana) |> 
  mutate(episodio = if_else(is.na(episodio),
                            0,
                            episodio))

# Run Length Encoding
# sirve p/contar la cantidad de veces seguidas que se repite un valor
# en este caso, las semanas con (1) o sin (0) episodio
# ?rle()
ordenado_lista <- rle(ordenado$episodio)

# tibble(largo = ordenado_lista[[1]], valor = ordenado_lista[[2]]) |> 
#   arrange(desc(largo)) |> 
#   filter(valor == 1) |> 
#   head(2)

# 20 semanas seguidas CON episodios, semana 17-36, 2021
# 13 semanas seguidas CON episodios, semana 12-24, 2020

HT_con_actividad <- HT_semana |> 
  mutate(semana = week(fecha)) |> 
  mutate(a침o = year(fecha)) |> 
  select(-episodio) |> 
  mutate(sem_a침o = glue("{semana}_{a침o}")) |> 
  filter(sem_a침o %in% c("17_2021", "36_2021", "12_2020", "24_2020")) |> 
  select(-sem_a침o) |> 
  mutate(fecha_date = fecha) |> 
  mutate(fecha = format(fecha, "%d %b %y") %>% str_remove(., "\\.")) |> 
  mutate(fecha = toupper(fecha))

HT_c1 <- HT_con_actividad[3:4, ]
HT_c2 <- HT_con_actividad[1:2, ]

# PALA
acla_c1 <- glue("<img src='{here('pic/pala.png')}' width='40' /><br>
                {diff(HT_c1$semana)+1} semanas<br>
               {HT_c1$fecha[1]} - {HT_c1$fecha[2]}")
acla_c2 <- glue("<img src='{here('pic/pala.png')}' width='40' /><br>
                {diff(HT_c2$semana)+1} semanas<br>
               {HT_c2$fecha[1]} - {HT_c2$fecha[2]}")

HT_escalera <- HT_trad |> 
  mutate(fecha = release_date |> ymd()) |> 
  select(fecha) |> 
  mutate(episodio = 1) |> 
  arrange(fecha) |> 
  mutate(total = cumsum(episodio))

cor1 <- HT_escalera |> 
  filter(fecha %in% HT_sin_actividad$fecha1 | fecha %in% HT_sin_actividad$fecha2) |> 
  select(fecha, total) |> 
  mutate(total = c(10, 10, 135, 135))

vert_sin_act <- tibble(x = cor1$fecha,
                       xend = cor1$fecha,
                       y = cor1$total - 5,
                       yend = cor1$total + 5)

cor2 <- HT_escalera |> 
  filter(fecha %in% HT_con_actividad$fecha_date) |> 
  select(-episodio)

vert_con_act <- tibble(x = cor2$fecha,
                       xend = cor2$fecha,
                       y = cor2$total - 5,
                       yend = cor2$total + 5)

vec_fecha_break <- ymd(paste0(2017:2023, "0701"))

ultimo <- HT_escalera |>
  slice(nrow(HT_escalera)) |> 
  mutate(fecha = format(fecha, "%d %b %y") %>% str_remove(., "\\.")) |> 
  mutate(fecha = toupper(fecha))

primero <- HT_escalera |>
  slice(1) |> 
  mutate(fecha = format(fecha, "%d %b %y") %>% str_remove(., "\\.")) |> 
  mutate(fecha = toupper(fecha))

# aclaraciones
ac_05 <- tibble(x = ymd(20201001, 20190101, 20220101, 20181201, 20160701, 20230201),
                y = c(200, 155, 140, 42, 40, 200),
                label = c(acla_c1, acla_c2, acla_s1, acla_s2,
                          glue("1<sup>er</sup> episodio<br>{primero$fecha}"),
                          glue("{ultimo$total} episodios<br>hasta el<br>{ultimo$fecha}")),
                hjust = c(.5, .5, .5, .5, 0, 0),
                vjust = 1)

# flechas
fl_05 <- tibble(x = ymd(20210701, 20180301, 20201001, 20190701, 20230701, 20161101), 
                y = c(115, 7, 160, 115, 202, 26),
                xend = ymd(20210301, 20170815, 20210701, 20200401, max(HT_d$fecha) + days(7), 20170401), 
                yend = c(132, 9, 148, 107, nrow(HT_d), 3))

g_escalera <- ggplot(data = HT_escalera, aes(x = fecha, y = total)) +
  # escalera
  geom_step(color = "#ee4121", linewidth = .5) +
  # aclaraciones
  geom_richtext(data = ac_05[1:4,], aes(x, y, label = label, hjust = I(hjust),
                                        vjust = I(vjust)),  inherit.aes = FALSE,
                color = "white", size = 3, fontface = "italic",
                family = "titillium", fill = NA, label.color = NA) +
  geom_richtext(x = ac_05$x[5], y = ac_05$y[5], label = ac_05$label[5],
                hjust = ac_05$hjust[5], vjust = ac_05$vjust[5],  inherit.aes = FALSE,
                color = "white", size = 3, fontface = "italic",
                family = "titillium", fill = NA, label.color = NA) +
  geom_richtext(x = ac_05$x[6], y = ac_05$y[6], label = ac_05$label[6],
                hjust = ac_05$hjust[6], vjust = ac_05$vjust[6],  inherit.aes = FALSE,
                color = "white", size = 3, fontface = "italic",
                family = "titillium", fill = NA, label.color = NA) +
  # flechas
  geom_curve(data = fl_05[1:2,], aes(x, y, xend = xend, yend = yend), color = "white",
             inherit.aes = FALSE, arrow.fill = "white", curvature = -.1, linewidth = .3, 
             arrow = arrow(angle = 10, length = unit(.3, "line"), type = "closed")) +
  geom_curve(data = fl_05[3:5, ], aes(x, y, xend = xend, yend = yend), color = "white",
             inherit.aes = FALSE, arrow.fill = "white", curvature = +.1, linewidth = .3, 
             arrow = arrow(angle = 10, length = unit(.3, "line"), type = "closed")) +
  geom_curve(x = fl_05$x[6], y = fl_05$y[6], xend = fl_05$xend[6], 
             yend = fl_05$yend[6], color = "white", inherit.aes = FALSE, 
             arrow.fill = "white", curvature = +.1, linewidth = .3, 
             arrow = arrow(angle = 10, length = unit(.3, "line"), type = "closed")) +
  # aclaraci칩n eje
  geom_richtext(x = ymd(20160901), y = 209, label = "Suma <br>acumulada<br>de episodios", 
                inherit.aes = FALSE, family = "titillium", color = "grey40", 
                size = 3, fill = NA, label.color = NA, hjust = 0, vjust = 1) +
  # ejes
  scale_x_date(breaks = vec_fecha_break,
               date_labels = "%Y", 
               limits = ymd(20170101, 20231231)) +
  scale_y_continuous(limits = c(0, 215),
                     expand = c(0, 0)) +
  labs(x = NULL, y = NULL,
       title = "PALA <span style='color:#ee4121;'>V</span> PALAN'T",
       subtitle = glue(
         "Durante las primeras <span style='color:#ee4121;'>{HT_s1$delta_semana} 
         semanas</span> de 2021 no hubo episodios de 
         <span style='color:#ffc10e;'>Hoy Trasnoche</span>,<br>el per칤odo 
         consecutivo m치s extenso <span style='color:#ee4121;'>sin actividad</span>. 
         Depu칠s, la <span style='color:#ffc10e;'>redenci칩n</span>, con<br>
         <span style='color:#ee4121;'>{diff(HT_c1$semana)+1} semanas</span> 
         ininterrumpidas de episodios, record actual de agarrar la pala."),
       caption = glue("{fuente} {sep} {autor} {sep} {icon_github} {icon_twitter} {usuario}")) +
  coord_cartesian(clip = "off") +
  theme_minimal() +
  theme(aspect.ratio = 1,
        # axis.text = element_text(color = "grey30"),
        axis.text.y = element_text(family = "mono", color = "grey90",
                                   size = 14),
        axis.text.x = element_text(family = "bebas", size = 18,
                                   color = alpha("grey30", 1),
                                   margin = margin(4, 0, 10, 0)),
        panel.grid.major.y = element_line(color = "grey30", linewidth = .1),
        panel.grid.minor.y = element_blank(),
        panel.grid.minor.x = element_line(color = "grey30", 
                                          linewidth = c(0, .1, .1, .1, .1, .1, .1)),
        panel.grid = element_blank(),
        panel.background = element_rect(fill = "black", color = NA),
        plot.background = element_rect(fill = "black", color = "grey30"),
        plot.title = element_markdown(size = 40, family = "friz_bold",
                                            color = "#ffc10e"),
        plot.title.position = "plot",
        plot.subtitle = element_markdown(color = "white", size = 12,
                                         family = "titillium",
                                         margin = margin(4, 0, 10, 0)),
        plot.caption = element_markdown(hjust = .5, family = "titillium",
                                        margin = margin(1, 0, 0, 0), size = 9),
        plot.caption.position = "plot",
        plot.margin = margin(5, 5, 5, 5))

ggsave(plot = g_escalera,
       filename = here("fig/HT_05.png"),
       width = 15.3,
       height = 19,
       units = "cm",
       dpi = 300)

# texto

record_con <- tibble(largo = ordenado_lista[[1]], valor = ordenado_lista[[2]]) |>
  arrange(desc(largo)) |>
  filter(valor == 1) |>
  head(2) |> 
  pull(largo)

fecha_ultimo_ep <- HT_trad |> 
  mutate(fecha = ymd(release_date)) |> 
  slice_max(fecha, n = 1) |> 
  pull(fecha) |> 
  format(x = _, "%d de %B de %Y")

```
:::

::: {.column-screen-inset-right}
![Los per칤odos de actividad ininterrumpida se indican como diagonales ascendentes. Las semanas en las que no hay episodios se visualizan como horizontales.](fig/HT_05.png){#fig-05 fig-align="center"}
:::

Como ninguno de los oyentes pone un mango por <ht>HOY TRASNOCHE</ht>, no podemos pedirles a los conductores que devuelvan la guita cuando no agarran la pala.

Pero si podemos analizar en qu칠 per칤odos fueron m치s consistentes y en cuales nos abandonaros.

La @fig-05 muestra un gr치fico de escalera. Avanza en direcci칩n horizontal cuando no hay cap칤tulo, y se mueve en vertical cuando hay episodio. Por lo tanto, extensos per칤odos sin cap칤tulos se muestran como rectas horizontales largas; y los per칤odos de mayor actividad y consistencia, con episodios todas las semanas, se ven como un serrucho diagonal.

Entre el 31 de diciembre de 2020 y el 23 de abril de 2021, en esas 15 semanas, no se public칩 nada. La secuencia m치s extensa sin episodios. El segundo per칤odo m치s largo sin actividad fue 12 semanas en 2017. Ambos per칤odos son coincidentes con los cuadros grises de la @fig-04.

<span style='background-color:#333333'>Antes de que me vengan a reclamar, s칤, salieron dos episodios, pero de Mat칩 Mil (el [trailer](https://open.spotify.com/episode/6pvVC3qbBz7vt8zXp5Mhnq) del podcast y en el que se habla del [Asesino del Zod칤aco](https://open.spotify.com/episode/2HbceZfm0kUKMnD4nM0Ksd)). Y como se mencion칩 en el @sec-intro, este tipo de contenido NO se considera.</span>

Luego de ese inicio complicado de 2021, vinieron `r record_con[1]` semanas ininterrumpidas de contenido. Agarrar la pala intensifies. La redenci칩n. En 2020 hubo un comportamiento similar, algo m치s corto, de `r record_con[2]` semanas seguidas.

A la derecha de la figura se muestra la cantidad total de episodios producidos, `r nrow(HT_trad)`, hasta el `r fecha_ultimo_ep`. Me gustar칤a decir que son s칩lo 98, pero las matem치ticas no me dejan.

# An치lisis de texto {#sec-tex}

<!-- https://quarto.org/docs/authoring/markdown-basics.html#text-formatting -->

Todas las palabras analizadas en esta secci칩n provienen de los textos presentes en los t칤tulos y descripciones de los episodios, seg칰n lo encontrado en Spotify. El primer an치lisis es la verificaci칩n de que los conductores son <ins>Flor</ins> y <ins>Calu</ins>, ninguna Florencia o Santiago (@fig-06); dos nubes de palabras, de acuerdo con el contenido en del t칤tulo y descripci칩n ([-@fig-07]); los pares de palabras que m치s veces aparecen acompa침adas ([-@fig-08]); y las palabras m치s importantes agrupadas por a침o ([-@fig-09]).

Tengo experiencia en manipular tablas y datos num칠ricos, pero tratar con texto fue algo completamente nuevo. Mucho de lo que se describe a continuaci칩n se llev칩 a cabo con el paquete [<code>{tidytext}</code>](https://juliasilge.github.io/tidytext/). Los gr치ficos e interpretaci칩n de los resultados siguieron muy de cerca los ejemplos encontrados en [Text Mining with R](https://www.tidytextmining.com/index.html).


## Flor y Calu. Calu y Flor {#sec-tex-nom}

::: {.column-screen-inset-right}
```{r 7_nombres_flor_calu}
# 6.- nombres -------------------------------------------------------------
library(wordcloud)
library(tidytext)
library(ggwordcloud)
library(widyr)
library(ggraph)
library(igraph)

f_calu <- glue("<img src='{here('pic/f_calu.png')}' width='60' />")
f_flor <- glue("<img src='{here('pic/f_flor.png')}' width='60' />")

HT_nombres <- HT_all %>% 
  # remuevo los episodios de HTD, Mat칩 Mil, entre otros
  filter(!name %in% vec_HT_otros) |> 
  mutate(a침o = year(ymd(release_date))) |> 
  # conservo 'id' y 'name'
  select(description, a침o) |> 
  # separo p/palabra
  unnest_tokens(word, description) %>% 
  # variaciones de los nombres
  filter(word %in% c("flor", "florencia", "fiorella", "santiago", "calo", "calu")) |> 
  # cuento
  count(word) |> 
  # agrupo por conductor
  mutate(tipo = if_else(word %in% c("flor", "fiorella"), "FLOR", "CALU")) |> 
  group_by(tipo) |> 
  # porcentaje
  mutate(porc = n/sum(n)*100) |> 
  ungroup() |> 
  # agrego columna vac칤a en "FLOR" para igualar 3 columnas por conductos
  bind_rows(tibble(word = NA_character_, n = NA_real_, tipo = "FLOR", 
                   porc = NA_real_)) |> 
  # nombre y porcentaje
  mutate(word = glue("{word}<span style='font-size:15px; color:grey40; font-family:mono'>{round(porc)}%</span>")) |> 
  # ordeno las palabras
  mutate(word = fct_reorder(word, porc, .na_rm = FALSE)) |> 
  # agrego las im치genes de los conductores y ordeno
  mutate(tipo = if_else(tipo == "FLOR", f_flor, f_calu)) |> 
  mutate(tipo = factor(tipo, levels = c(f_calu, f_flor)))

po_flor <- HT_nombres |> 
  filter(str_detect(word, "flor")) |> 
  pull(porc) |> 
  round()

po_calu <- HT_nombres |> 
  filter(str_detect(word, "calu")) |> 
  pull(porc) |> 
  round()

g_nombres <- ggplot(data = HT_nombres,
                    aes(x = porc, y = tipo, fill = word)) +
  # columna (fina)
  geom_col(position = position_dodge(width = .3, preserve = "total"), 
           show.legend = FALSE,
           width = .2, color = "yellow") +
  # nombre y porcentaje
  geom_richtext(aes(label = word, group = word, x = porc + 1), family = "bebas",
                show.legend = FALSE, fill = NA, vjust = .62, size = 10,
                color = "white", label.color = NA, hjust = 0,
                position = position_dodge(width = .3))+
  # manual
  scale_fill_manual(values = rep("red", 6)) +
  # ejes
  labs(x = NULL, y = NULL,
       title = "LAS COSAS POR<br>SU <span style='color:#ee4121;'>NOMBRE</span>",
       subtitle = glue(
         "A partir de la descripci칩n de los episodios, el 
         <span style='color:#ee4121;'>{po_flor}%</span> de las
         veces Fiorella Sargenti<br>es llamada <span style='color:#ffc10e;'>Flor</span>. 
         Por su parte, Santiago Calori, el <span style='color:#ee4121;'>{po_calu}%</span> 
         de las veces es <span style='color:#ffc10e;'>Calu</span>."),
       caption = glue("{fuente} {sep} {autor} {sep} {icon_github} {icon_twitter} {usuario}")) +
  coord_cartesian(clip = "off") +
  theme_minimal() +
  theme(aspect.ratio = 1,
        panel.border = element_rect(color = NA, fill = NA),
        panel.spacing.y = unit(1.5, "line"),
        axis.text = element_blank(),
        axis.text.y = element_markdown(),
        panel.grid = element_blank(),
        panel.background = element_rect(fill = "black", color = NA),
        plot.background = element_rect(fill = "black", color = "grey30"),
        plot.title = element_markdown(size = 40, family = "friz_bold",
                                      color = "#ffc10e"),
        plot.title.position = "plot",
        plot.subtitle = element_markdown(color = "white", size = 12,
                                         family = "titillium",
                                         margin = margin(4, 0, 10, 0)),
        plot.caption = element_markdown(hjust = .5, family = "titillium", 
                                        size = 9,
                                        margin = margin(40, 0, 0, 55)),
        plot.caption.position = "plot",
        plot.margin = margin(5, 60, 5, 5))

ggsave(plot = g_nombres,
       filename = here("fig/HT_06.png"),
       width = 15,
       height = 17,
       units = "cm",
       dpi = 300)

```
:::

::: {.column-screen-inset-right}
![Diagrama de barras con los porcentajes de los t칠rminos m치s frecuentes para mencionar a los conductores, Fiorella Sargenti y Santiago Calori.](fig/HT_06.png){#fig-06 fig-align="center"}
:::

Comienzo el an치lisis de palabras individuales comparando los nombres usados para denominar a los conductores encontrados en las descripciones. Se omitieron los apellidos. En el caso de Fiorella Sargenti, se buscaron las siguientes palabras: <code>Fiorella</code>, <code>Fio</code>, <code>Florencia</code> y <code>Flor</code>. De acuerdo con la @fig-06, en ninguna oportunidad se utiliza los t칠rminos <code>Fio</code> o <code>Florencia</code> para referirse a Sargenti. En el caso de Santiago Calori, se buscaron las palabras <code>Calo</code>, <code>Calu</code> y <code>Santiago</code>.

Sargenti es claramente Flor, sin lugar a duda. Siempre lo supimos, no es nada nuevo, pero que la estad칤stica est칠 de acuerdo es satisfactorio. Personalmente, siempre pens칠 en Calori como Cal<ins>o</ins>, pero no, es Cal<ins>u</ins>.

Las caras de Flor y Calu las saqu칠 de [este](https://www.instagram.com/p/BSzcCh5Bwyi/) post en Instagram, publicada el d칤a del primer episodio. 칄ramos tan j칩venes.

Ya que estamos, mi foto favorita de [Flor](https://www.instagram.com/p/B_YDJIPAcmM/), de [Calu](https://www.instagram.com/p/CAf_wyHgysM/) y [ambos](https://www.instagram.com/p/BrXuVtUlB27/).

## Nubes de palabras {#sec-tex-nube}

::: {.column-screen-inset-right}
```{r 8_nube_de_palabras}
# 7.- nube de palabras ----------------------------------------------------

# palabras comunes: en espa침ol, ingl칠s (por el t칤tulo de muchas pel칤culas) y
# propio (personalizado)

palabras_comunes <- c(tm::stopwords("es"),
                      tm::stopwords("en"),
                      as.character(1:20),
                      as.character(2017:2023),
                      # remuevo los nombres de los conductores y palabras comunes
                      "hoy", "trasnoche", "florencia", "flor", "santiago",
                      "calori", "calu", "sargenti", "fiorella", "si", "s칠", 
                      "vos", "puede", "bien", "ac치", "vol", "va", "c칩mo", "vez",
                      "podcast", "episodio", "funci칩n", "ver", "vas", "adem치s",
                      "dos", "hace", "hizo", "l", "ron", "euq", "ne", "dej칩")

# t칤tulo
HT_titulo <- HT_all %>% 
  # remuevo los episodios de HTD, Mat칩 Mil, entre otros
  filter(!name %in% vec_HT_otros) |> 
  # conservo 'id' y 'name'
  select(name, id) |> 
  # separo p/palabra
  unnest_tokens(word, name) %>% 
  # remuevo palabras comunes (y, de, la, lo, has, etc)
  anti_join(tibble(word = palabras_comunes), by = join_by(word))

# top de palabras m치s frecuentes
n_top_tit <- 37

# tibble con las 'n_top_tit' palabras m치s frecuentes
HT_top_tit <- HT_titulo |> 
  count(word, sort = TRUE) |> 
  slice_max(n, n = n_top_tit, with_ties = FALSE) 

# agrego colores
set.seed(2017); HT_nube_titulo <- HT_top_tit |> 
  mutate(color = rep(c("#ffc10e", "#ee4121"), length.out = nrow(HT_top_tit)) |> 
           sample()) 

g_nube_tit <- ggplot(data = HT_nube_titulo) + 
  # palabras
  geom_text_wordcloud_area(aes(label = word, size = n, color = I(color)),
                           seed = 2023) +
  scale_size_area(max_size = 14) +
  coord_cartesian(clip = "off") +
  labs(title = "T칤tulo",
       subtitle = glue("{nrow(HT_top_tit)} palabras m치s frecuentes")) +
  theme_void() +
  theme(aspect.ratio = 1.25,
        plot.background = element_rect(fill = "black", color = NA),
        plot.title = element_markdown(size = 20, family = "bebas",
                                      color = "grey", hjust = .5),
        plot.title.position = "panel",
        plot.subtitle = element_markdown(color = "grey40", size = 10,
                                         family = "titillium", hjust = .5),
        plot.margin = margin(5, 5, 5, 5))

# descripci칩n
HT_descr <- HT_all %>% 
  # remuevo los episodios de HTD, Mat칩 Mil, entre otros
  filter(!name %in% vec_HT_otros) |> 
  # conservo 'id' y 'name'
  select(description, id) |> 
  # separo p/palabra
  unnest_tokens(word, description) %>% 
  # remuevo palabras comunes (y, de, la, lo, has, etc)
  anti_join(tibble(word = palabras_comunes), by = join_by(word))

# top de palabras m치s frecuentes
n_top_desc <- 40

# tibble con las 'n_top' palabras m치s frecuentes
HT_top_desc <- HT_descr |> 
  count(word, sort = TRUE) |> 
  slice_max(n, n = n_top_desc, with_ties = FALSE) 

# agrego colores
set.seed(2019); HT_nube_desc <- HT_top_desc |> 
  mutate(color = rep(c("#ffc10e", "#ee4121"), length.out = nrow(HT_top_desc)) |> 
           sample()) 

oti <- glue("<img src='{here('pic/oti.png')}' width='20' />")

g_nube_desc <- ggplot(data = HT_nube_desc) + 
  # oti
  geom_richtext(x = Inf, y = -Inf, label = oti, inherit.aes = FALSE,
                fill = NA, label.color = NA, label.r = unit(.7, "line"),
                label.padding = unit(.1, "line")) +
  # nube de palabras
  geom_text_wordcloud_area(aes(label = word, size = n, color = I(color)),
                           seed = 2023) +
  scale_size_area(max_size = 22) +
  coord_cartesian(clip = "off") +
  labs(title = "Descripci칩n",
       subtitle = glue("{nrow(HT_nube_desc)} palabras m치s frecuentes")) +
  theme_void() +
  theme(aspect.ratio = 1.25,
        plot.background = element_rect(fill = "black", color = NA),
        plot.title = element_markdown(size = 20, family = "bebas",
                                      color = "grey", hjust = .5),
        plot.title.position = "panel",
        plot.subtitle = element_markdown(color = "grey40", size = 10,
                                         family = "titillium", hjust = .5),
        plot.margin = margin(5, 5, 5, 5))

# PLOT COMPUESTA
set.seed(99); g_nube_comp <- g_nube_tit + g_nube_desc &
  plot_annotation(
    title = "쮻E QU칄 SE HABLA EN<br><span style='color:#ffc10e;'>HOY TRASNOCHE</span>?",
    subtitle = "B치sicamente, de <span style='color:#ffc10e;'>cine</span> y 
    <span style='color:#ffc10e;'>porongas</span>. A partir del contenido en el 
    t칤tulo y en la descripci칩n se<br>hicieron dos <span style='color:#ee4121;'>nubes 
    de palabras</span>, que muestran cu치les son las palabras m치s recurrentes.",
    caption = glue("{fuente} {sep} {autor} {sep} {icon_github} {icon_twitter} {usuario}"),
    theme = theme(
      plot.background = element_rect(color = "grey30",
                                     fill = "black"),
      plot.title.position = "plot",
      plot.title = element_markdown(size = 35, family = "friz_bold",
                                    color = "#ee4121", align_widths = TRUE,
                                    margin = margin(2, 2, 2, 10)),
      plot.subtitle = element_markdown(color = "white", size = 12,
                                       family = "titillium",
                                       margin = margin(2, 2, 2, 10)),
      plot.caption = element_markdown(hjust = .5, family = "titillium",
                                      margin = margin(1, 0, 0, 0), size = 9),
      plot.caption.position = "plot",
      plot.margin = margin(8, 17, 2, 0)))

ggsave(plot = g_nube_comp,
       filename = here("fig/HT_07.png"),
       width = 17,
       height = 15,
       units = "cm",
       dpi = 300)
```
:::

::: {.column-screen-inset-right}
![Nubes de palabras, generadas a partir de dos conjuntos de datos: los t칤tulos y las descripciones.](fig/HT_07.png){#fig-07 fig-align="center"}
:::

Las nubes de palabras son una manera muy visual de tener una idea de qu칠 t칠rminos son m치s frecuentes en documentos, libros, o en este caso, los t칤tulos y descripciones de los episodios de <ht>HOY TRASNOCHE</ht>.

Se contaron todas las palabras presentes en ambos grupos de datos, y se ordenaron de mayor a menor. Para el t칤tulo se tomaron las 37 palabras m치s frecuentes. En el primer puesto, para felicidad de todo el pueblo trasnochiter, est치 <code>poronga</code>, con 8 repeticiones, seguido de <code>pel칤cula</code> (6) y <code>caca</code> (5). Todas las palabras de la nube tienen al menos 2 repeticiones en los t칤tulos.

Respecto de la nube de palabras de la descripci칩n (lado derecho de la @fig-07), dado que hay una mayor cantidad de palabras, las repeticiones son mayores. En el primer puesto tenemos, con 235 apariciones, el t칠rmino <code>cine</code>. Para todos los que se preguntaban si <ht>HOY TRASNCOCHE</ht> es un podcast de cine. Luego siguen <code>semana</code> (187) y <code>pel칤culas</code> (100). Todas las palabras tienen al menos 17 apariciones entre todas las descripciones.

Vemos t칠rminos hist칩ricos como <code>videoclub</code> (96) y <code>portarretratos</code> (95), y t칠rminos m치s recientes como <code>Oti</code> (25).

Todas las cosas que amamos de <ht>HOY TRASNOCHE</ht> est치n resumidas en estas dos nubes de palabras. El amor por el cine, los caprichos de Flor, los <ht>HOY PORONGA</ht>, caca, falopa, coyuntura. Todo lo que quieren las guachas.

## Temas importantes {#sec-tex-imp}

::: {.column-screen-inset-right}
```{r 9_importancia_tf_idf}
# 8.- tf-idf --------------------------------------------------------------
# browseURL("https://www.tidytextmining.com/tfidf.html#the-bind_tf_idf-function")

pro <- tibble(x = c(1, 6), y = c(4, 2)) |> 
  lm(y ~ x, data = _) |> coef()

HT_importancia <- HT_all |> 
  # remuevo los episodios de HTD, Mat칩 Mil, entre otros
  filter(!name %in% vec_HT_otros) |> 
  # conservo 'id' y 'name'
  select(description, release_date) |> 
  # separo p/palabra
  unnest_tokens(word, description) |> 
  # remuevo palabras comunes (y, de, la, lo, has, etc)
  anti_join(tibble(word = palabras_comunes), by = join_by(word)) |> 
  mutate(a침o = year(ymd(release_date))) |> 
  select(-release_date) |> 
  group_by(a침o) |> 
  count(word) |> 
  # importancia de c/palabra, comparando entre a침os
  bind_tf_idf(word, a침o, n) |> 
  arrange(desc(tf_idf)) |> 
  # tf != 1, IMPORTANTE
  filter(!near(tf, 1)) |> 
  # elijo las 1ras 6 palabras
  slice_head(n = 6) |> 
  # print(n=100)
  ungroup() |> 
  # label
  mutate(word2 = str_to_sentence(word)) |> 
  # paso 'word' a factor, ordenado por 'n', dentro de c/a침o
  mutate(word = reorder_within(x = word, by = tf_idf, within = a침o)) |> 
  # paso a oraci칩n
  mutate(word = str_to_sentence(word)) |> 
  mutate(word = fct_reorder(word, tf_idf)) |> 
  # puesto
  mutate(puesto = rep(1:6, 7) |> as.character()) |> 
  # tama침o puesto
  mutate(puesto_tam = pro[1] + pro[2]*as.numeric(puesto)) |> 
  # alpha puesto
  mutate(puesto_alpha = 1.14 -.14*as.numeric(puesto))

la <- HT_importancia |> 
  filter(a침o >= 2021) |> 
  group_by(a침o) |> 
  filter(row_number() == 1) |> 
  ungroup() |> 
  mutate(pic = c("n_la.png", "oti.png", "oti.png")) |> 
  mutate(ancho = c(20, 35, 35)) |> 
  mutate(etq = glue("<img src='{here('pic')}/{pic}' width='{ancho}' />"))

g_tfidf <- ggplot(data = HT_importancia, 
                  aes(x = 0, y = word, label = word2)) +
  # listado de palabras
  geom_text(show.legend = FALSE, hjust = 0, color = "white", nudge_x = .015,
            family = "titillium", size = 4, vjust = 0) +
  # puesto
  geom_text(aes(label = puesto, x = 0, y = as.numeric(puesto) |> rev(), 
                alpha = I(puesto_alpha)), 
            inherit.aes = FALSE, family = "mono", color = "#ffc10e", 
            size = 3,
            hjust = 1, vjust = 0, nudge_y = 0, fontface = "bold") +
  # Laffie
  geom_richtext(data = la, aes(x = .7, y  = word, label = etq),
                fill = NA, label.color = NA, vjust = .2) +
  facet_wrap(~ a침o, scales = "free", ncol = 4) +
  # manual
  scale_x_continuous(limits = c(0, 1)) +
  scale_y_reordered() +
  # eje
  labs(x = NULL, y = NULL,
       title = "LO M츼S <span style='color:#ee4121;'>IMPORTANTE</span>, A칌O A A칌O",
       subtitle = "Se muestran las <span style='color:#ffc10e;'>seis palabras</span> m치s relevantes, en 
       orden descendente de <span style='color:#ee4121;'>importancia</span><sup style='color:#ffc10e; font-size:15px'>****</sup>.<br> 
       Las palabras provienen de la <span style='color:#ffc10e;'>descripci칩n</span> de los episodios, agrupadas por 
       a침o.",
       tag = "<sup style='color:#ffc10e; font-size:15px'>****</sup>La importancia 
       de<br>cada palabras se<br>obtuvo mediante el<br>칤ndice 
       <span style='color:grey70;'>**tf-idf**</span>, frecuencia<br> de 
       t칠rmino-frecuencia<br>inversa de documento.",
       caption = glue("{fuente} {sep} {autor} {sep} {icon_github} {icon_twitter} {usuario}")) +
  coord_cartesian(clip = "off") +
  theme_minimal() +
  theme(aspect.ratio = 1,
        panel.border = element_rect(color = NA, fill = NA),
        panel.spacing.y = unit(1.5, "line"),
        axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        panel.grid = element_blank(),
        panel.background = element_rect(fill = "black", color = NA),
        strip.text = element_text(color = "#ee4121", family = "bebas", 
                                  size = 30, hjust = 0),
        plot.background = element_rect(fill = "black", color = "grey30"),
        plot.title = element_textbox_simple(size = 35, family = "friz_bold",
                                            color = "#ffc10e"),
        plot.title.position = "plot",
        plot.subtitle = element_markdown(color = "white", size = 12,
                                         family = "titillium",
                                         margin = margin(4, 0, 20, 0)),
        plot.caption = element_markdown(hjust = .5, family = "titillium",
                                        margin = margin(25, 0, 0, 0), size = 9),
        plot.caption.position = "plot",
        plot.margin = margin(11, 5, 11, 5),
        plot.tag = element_markdown(color = "grey45", size = 10, family = "titillium",
                                hjust = 0),
        plot.tag.position = c(.75, .13))

ggsave(plot = g_tfidf,
       filename = here("fig/HT_08.png"),
       width = 16,
       height = 17,
       units = "cm",
       dpi = 300)
```
:::

::: {.column-screen-inset-right}
![Top 6 de palabras m치s relevantes, en orden descendente, agrupadas por a침o.](fig/HT_08.png){#fig-08 fig-align="center"}
:::

La frecuencia de palabras individuales en un buen par치metro para analizar la relevancia de los t칠rminos en una obra completa, como ser el conjunto total de t칤tulos, o descripciones. 칔til para generar una nube de palabras (@fig-07). Sin embargo, al considerar diferentes grupos, como ser las descripciones agrupadas por a침o, no es suficiente para entender cu치les palabras son las m치s destacadas.

El mecanismo para obtener la importancia de las palabras es <ins>Term frequency  Inverse document frequency</ins> (tf-idf, frecuencia de t칠rmino  frecuencia inversa de documento). Las palabras m치s frecuentes a lo largo de todas las descripciones, de todos los a침os, dan una idea de su relevancia (tf), y deben ser consideradas. Sin embargo, algunas palabras pueden repetirse constantemente durante todos los a침os, por lo que no son 칰tiles para identificar espec칤ficamente las palabras relevantes de un a침o particular. Es conveniente disminuir su impacto (idf).
El tf-idf permite cuantificar la importancia de las palabras considerando los efectos de repetici칩n y compensar su relevancia al comparar diferentes grupos. As칤 es posible encontrar, para cada a침o, cu치les son las palabras m치s importantes, aquellas que definieron el a침o.

La @fig-08 muestra listas de seis palabras, ordenadas de mayor a menor importancia, por a침o. Podemos ver como la cuenta de Instagram, [<code>@filmejuntoalpueblo</code>](https://www.instagram.com/filmejuntoalpueblo/), estuvo muy presente en el primer a침o. Aparecen auspiciantes en 2018 y 2020. Secciones viejas conocidas de <ht>HOY TRASNOCHE</ht>, como el <code>portarretratos</code> y el <code>videoclub</code>, tambi칠n presentes en la nube de palabras. 2021 fue el a침o donde todos aprendimos (y casi nos convertimos) a la religi칩n creada por Lafayette Ronald <code>Hubbard</code>, el querido <code>Laffie</code>. Nuestra mascota preferida <code>Oti</code> tiene su aparici칩n estelar en 2022, y en lo que vamos de 2023 vemos la presencia del <code>Chico</code> de <code>Redes</code>.

## Pares de palabras {#sec-tex-big}

::: {.column-screen-inset-right}
```{r 10_bigrama}
pc <- c(stop_words$word, tm::stopwords("es"))
vec_flor <- c("fiorella", "sargenti", "flor", "florencia")
vec_calo <- c("santiago", "calori", "calo", "calu")

# CONTEO
HT_bigram <- HT_all |> 
  select(description) |> 
  unnest_tokens(bigram, description, token = "ngrams", n = 2) |> 
  separate(bigram, c("word1", "word2"), sep = " ") |> 
  filter(!word1 %in% pc,
         !word2 %in% pc) |> 
  count(word1, word2, sort = TRUE) |> 
  # saco los n칰meros
  filter(n > 4,
         !str_detect(word1, "\\d"),
         !str_detect(word2, "\\d")) |> 
  mutate(across(-n, str_to_sentence)) |> 
  # remuevo palabras que se repiten en ambas columnas (word1 == word2)
  mutate(n = if_else(word1 == word2, NA_real_, n)) |> # print(n = 100)
  drop_na(n) |> 
  # HBO
  mutate(word1 = case_match(word1,
                            "Hbo" ~ "HBO",
                            .default = word1))

n_palabras_pares <- length(unique(c(HT_bigram$word1, HT_bigram$word2)))

cel <- tibble(n = paste0("n_", c("ah", "sl", "nc", "ow", "em"))) |> 
  mutate(label = glue("<img src='{here('pic')}/{n}.png' width='20' />")) |> 
  mutate(x = c(-Inf, -Inf, Inf, Inf, 0)) |> 
  mutate(y = c(Inf, -Inf, Inf, -Inf, -1))

set.seed(2024); g_bigram <- HT_bigram %>%
  graph_from_data_frame() %>%
  ggraph(layout = "fr") +
  # celebridades
  geom_richtext(data = cel, aes(x = x, y = y, label = label), 
                inherit.aes = FALSE, fill = NA, label.color = NA) +
  # nodos
  geom_node_point(color = "#ee4121", size = 1, shape = 16, alpha = 1) +
  # l칤neas de uni칩n
  geom_edge_link(show.legend = FALSE,
                 angle_calc = "along",
                 color = "#ffc10e",
                 alpha = .5,
                 end_cap = circle(.1, 'line'),
                 start_cap = circle(.1, 'line'),
                 arrow = arrow(angle = 12, type = "open",
                               length = unit(.4, "line"))) +
  # etiqueta
  geom_node_label(aes(label = name), vjust = .5, hjust = .5, color = "white",
                  repel = TRUE, fill = alpha("grey40", .1),
                  label.r = unit(0, "line"), label.size = unit(0, "line"),
                  label.padding = unit(.1, "line")) +
  theme_void() +
  labs(x = NULL, y = NULL,
       title = "PALABRAS <span style='color:#ee4121;'>CRUZADAS</span>",
       subtitle = glue("Pares de palabras que usualmente se encuentran acompa침adas. 
       El sentido de<br>las flechas indica el orden entre ellas. Son 
       <span style='color:#ffc10e;'>{n_palabras_pares}</span> palabras 
       extra칤das de la descripci칩n<br>de los episodios."),
       caption = glue("{fuente} {sep} {autor} {sep} {icon_github} {icon_twitter} {usuario}")) +
  coord_cartesian(clip = "off") +
  theme_void() +
  theme(aspect.ratio = 1,
        panel.border = element_rect(color = NA, fill = NA),
        panel.spacing.y = unit(1.5, "line"),
        axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        panel.grid = element_blank(),
        panel.background = element_rect(fill = "black", color = NA),
        strip.text = element_text(color = "#ee4121", family = "bebas", 
                                  size = 30, hjust = 0),
        plot.background = element_rect(fill = "black", color = "grey30"),
        plot.title = element_markdown(size = 32, family = "friz_bold",
                                      color = "#ffc10e"),
        plot.title.position = "plot",
        plot.subtitle = element_markdown(color = "white", size = 12,
                                         family = "titillium",
                                         margin = margin(4, 0, 10, 0)),
        plot.caption = element_markdown(hjust = .5, family = "titillium",
                                        margin = margin(15, 0, 0, 0), size = 9),
        plot.caption.position = "plot",
        plot.margin = margin(5, 20, 5, 15),
        plot.tag = element_markdown(color = "grey40", size = 10, family = "titillium",
                                    hjust = 0),
        plot.tag.position = c(.75, .13))

ggsave(plot = g_bigram,
       filename = here("fig/HT_09.png"),
       width = 15,
       height = 18,
       units = "cm",
       dpi = 300)

# texto

max_par_1 <- HT_bigram |> 
  slice_max(n, n = 1) |> 
  pull(n)

max_par_flor <- HT_bigram |> 
  filter(word1 == "Fiorella") |> 
  pull(n)

max_par_calu <- HT_bigram |> 
  filter(word1 == "Santiago") |> 
  pull(n)

max_par_nic <- HT_bigram |> 
  filter(word1 == "Nicolas") |> 
  pull(n)

max_par_armie <- HT_bigram |> 
  filter(word1 == "Armie") |> 
  pull(n)
```
:::

::: {.column-screen-inset-right}
![Pares de palabras consecutivas que aparecen m치s frecuentemente, de acuerdo a los t칠rminos encontrados en las descripciones de los episodios.](fig/HT_09.png){#fig-09 fig-align="center"}
:::

Los an치lisis de texto vistos hasta ahora involucraban palabras individuales, aisladas. En la @fig-09 se muestran las secuencias consecutivas m치s frecuentes de dos palabras, llamado **bigrama**, formado a partir de los t칠rminos de todas las descripciones. No se consider칩 el texto presente en los t칤tulos, ya que son secuencias cortas de palabras. 

Un bigrama muestra los pares de palabras que m치s com칰nmente aparecen juntas. Por ejemplo, es un buen ejercicio para identificar nombres propios en una novela, entendidos como secuencias de dos palabras compuestas por el nombre inmediatamente seguido del apellido.

Dada la naturaleza del texto analizado organizado en oraciones, es relevante investigar cuales palabras aparecen siempre acompa침adas unas de otras.

Todos los pares de palabras de la figura aparecen al menos 5 veces. No se muestra la cantidad de apariciones de cada par de palabras, para no cargar demasiado la figura. En el primer puesto est치, claro, <ht>HOY TRASNOCHE</ht>, con `r max_par_1` repeticiones. Seguido de los nombres formales de quienes conducen, <code>Fiorella Sargenti</code> (95) y <code>Santiago Calori</code> (94). Aunque ya establecimos sus verdaderos nombres en la @sec-tex-nom.

Aparecen cinco celebridades, viejos conocidos de las coyunturas. <code>Ezra Miller</code> y <code>Nic Cage</code> comparten el primer puesto con 7 apariciones. Nic es el 칰nico que aparece por hacer su trabajo y no por estar metido en quilombos. M치s de esto en la @sec-pel-elenco. Armie, Olivia y Shia coinciden en 5 apariciones, aunque tengo la sensaci칩n de que los mencion칩 mucho m치s.

Se ven pares de palabras aisladas, como <code>HBO Max</code> y <code>posta offline</code>. Tambi칠n hay agrupaciones, como <code>nuevo episodio</code> y <code>칰ltimo episodio</code> (n칩tese el sentido de las flechas). El grupo m치s grande incluye los temas centrales de <ht>HOY TRASNOCHE</ht>: <code>Calu</code>, <code>Flor</code>, <code>cine</code>, <code>pel칤culas</code>, <code>semana</code>, entro otros.

# An치lisis de im치genes {#sec-img}

::: {.column-screen-inset-right}
```{r 11_miniaturas_imagenes}
# 10.- miniatura ----------------------------------------------------------
library(jpeg)
library(grid)

# descarga de las im치genes, 640x640
mini_desc <- read_tsv(here("data/spotify_datos_url.tsv")) |> 
  select(release_date, url, height) |> 
  mutate(fecha = ymd(release_date)) |> 
  filter(height == 64) |> 
  select(fecha, url) |> 
  mutate(file = glue("{format(fecha, '%Y%m%d')}_{str_sub(url, start = -5, end = -1)}"))

# funci칩n para descarga autom치tica de todas las miniaturas de HT, 
# en tama침o 64x64, .jpg
# map2(.x = mini_desc$url,
#      .y = glue("{here()}/mini_64/{mini_desc$file}.jpg"),
#      ~ download.file(url = .x, destfile = .y, method = "curl"))

fecha_misc <- HT_all |>
  filter(name %in% c(vec_HT_matomil, vec_HT_misc)) |>
  mutate(fecha = ymd(release_date)) |>
  select(name, fecha) |>
  mutate(fecha = format(fecha, "%Y%m%d")) |>
  pull(fecha)

files <- tibble(files = list.files(path = here("mini_64"), pattern = ".jpg",
                                   full.names = TRUE),
                files_n = list.files(path = here("mini_64"), pattern = ".jpg",
                                     full.names = FALSE)) |>
  separate(col = files_n, into = c("fe", NA), sep = "_") |>
  filter(!fe %in% fecha_misc) |>
  pull(files)

# leo los archivos
mini_lista <- map(.x = files, ~ readJPEG(.x))

# convierto a r치ster, en formato HEX (tengo acceso a los colores RGB)
raster_lista <- map(.x = mini_lista, ~ as.raster(.x))

# convierto a valores RGB (0-255)
mat_rgb_lista <- map(.x = raster_lista, ~ col2rgb(.x))

# vector de archivos 칰nicos (10 elementos)
vec_arc_u_640 <- tibble(mat_rgb = mat_rgb_lista) |> 
  # obtengo los valores medios p/c color (R, G, B)
  mutate(rojo = map(.x = mat_rgb, ~ mean(.x[1, ])) |> list_simplify()) |> 
  mutate(verde = map(.x = mat_rgb, ~ mean(.x[2, ])) |> list_simplify()) |> 
  mutate(azul = map(.x = mat_rgb, ~ mean(.x[3, ])) |> list_simplify()) |> 
  # calculo el color medio global de c/imagen
  mutate(color_prom = rgb(rojo, verde, azul, 
                          maxColorValue = 255)) |> 
  select(color_prom) |> 
  # archivos 640
  mutate(arch = str_replace(files, "mini_64", "mini_640")) |> 
  mutate(fecha = str_sub(arch, -18, -10) |> ymd()) |> 
  arrange(fecha) |> 
  mutate(color_prom = fct_reorder(color_prom, fecha)) |> 
  mutate(unic = as.numeric(color_prom)) |> 
  # 1 = 3; 4 = 5; 7 = 13; 12 = 14
  mutate(unic = case_match(unic,
                           3 ~ 1,
                           5 ~ 4,
                           13 ~ 7,
                           14 ~ 12,
                           .default = unic)) |> 
  mutate(unic = factor(unic)) |> 
  group_by(unic) |> 
  filter(row_number() == 1) |> 
  pull(arch)

HT_mini <- tibble(mat_rgb = mat_rgb_lista) |> 
  # obtengo los valores medios p/c color (R, G, B)
  mutate(rojo = map(.x = mat_rgb, ~ mean(.x[1, ])) |> list_simplify()) |> 
  mutate(verde = map(.x = mat_rgb, ~ mean(.x[2, ])) |> list_simplify()) |> 
  mutate(azul = map(.x = mat_rgb, ~ mean(.x[3, ])) |> list_simplify()) |> 
  # calculo el color medio global de c/imagen
  mutate(color_prom = rgb(rojo, verde, azul, 
                          maxColorValue = 255)) |> 
  select(color_prom) |> 
  # archivos 640
  mutate(arch = str_replace(files, "mini_64", "mini_640")) |> 
  mutate(fecha = str_sub(arch, -18, -10) |> ymd()) |> 
  arrange(fecha) |> 
  mutate(color_prom = fct_reorder(color_prom, fecha)) |> 
  mutate(unic = as.numeric(color_prom)) |> 
  # 1 = 3; 4 = 5; 7 = 13; 12 = 14
  mutate(unic = case_match(unic,
                           3 ~ 1,
                           5 ~ 4,
                           13 ~ 7,
                           14 ~ 12,
                           .default = unic)) |> 
  mutate(unic = factor(unic)) |> 
  mutate(u = as.numeric(unic)) |> 
  mutate(u = LETTERS[u] |> factor() |> fct_rev())

# miniaturas 칰nicas y su LETRA correspondiente
# HT_mini |> 
#   group_by(u) |> 
#   filter(row_number() == 1) |> 
#   ungroup() |> 
#   select(fecha, u)

# fecha inicial
mini_i <- HT_mini |> 
  group_by(u) |> 
  filter(row_number() == 1) |> 
  ungroup() |> 
  select(fecha, u) |> 
  mutate(fecha2 = format(fecha, "%d<br>%b<br>%y") %>% str_remove(., "\\.") |> toupper())

# fecha final
mini_f <- HT_mini |> 
  group_by(u) |> 
  filter(row_number() == max(row_number())) |> 
  ungroup() |> 
  select(fecha, u) |> 
  anti_join(mini_i, by = c("fecha", "u")) |> 
  mutate(fecha2 = format(fecha, "%d<br>%b<br>%y") %>% str_remove(., "\\.") |> toupper())

# eje horizontal
vec_fecha_break <- ymd(paste0(2017:2023, "0701"))

mini_izq <- tibble(arch = list.files(path = here("u_640"),
                                     pattern = ".jpg$",
                                     full.names = TRUE)[5:1]) |> 
  mutate(mini = glue("<img src='{arch}' width='100' />")) |> 
  mutate(let = LETTERS[5:1]) |> 
  mutate(x = 0) |> 
  mutate(y = seq(-4, 16, length.out = 5))

mini_der <- tibble(arch = list.files(path = here("u_640"),
                                     pattern = ".jpg$",
                                     full.names = TRUE)[10:6]) |> 
  mutate(mini = glue("<img src='{arch}' width='100' />")) |> 
  mutate(let = LETTERS[10:6]) |> 
  mutate(x = 0) |> 
  mutate(y = seq(-4, 16, length.out = 5))

grid_h <- tibble(x = ymd(20170101), 
                 xend = ymd(20240101), 
                 y = seq(.5, 9.5, 1), 
                 yend = y)

ac_10 <- tibble(x = ymd(20180101, 20190101), y = c(11.25, 10.4),
                label = c("Primer uso de<br>la imagen",
                          "칔ltimo uso de<br>la imagen"),
                hjust = 0, vjust = 1)

fl_10 <- tibble(x = ymd(20171215, 20190101), y = c(11, 10.4),
                xend = ymd(20170401, 20180301), yend = c(10.4, 10.1))

g_m2 <- ggplot(data = HT_mini, aes(x = fecha, y = as.numeric(u))) +
  # grilla
  geom_vline(xintercept = seq.Date(ymd(20170101), ymd(20230101), "1 year"),
             color = "grey30", linewidth = .1) +
  geom_segment(data = grid_h, aes(x = x, xend = xend, y = y, yend = yend),
               inherit.aes = FALSE, color = "grey30", linewidth = .1) +
  # eje vertical izq
  geom_text(aes(label = u, x = ymd(20160301)), color = "white", family = "bebas",
            size = 11) +
  # puntos
  geom_point(shape = "|", color = "#ffc10e", size = 5, alpha = .8) +
  # fecha i
  geom_richtext(data = mini_i, aes(x = fecha, y = as.numeric(u), label = fecha2), color = "white",
                size = 3, nudge_x = -.1, nudge_y = 0, hjust = 1, vjust = .5,
                fill = NA, label.color = NA, family = "titillium") +
  # fecha f
  geom_richtext(data = mini_f, aes(x = fecha, y = as.numeric(u), label = fecha2), color = "white",
                size = 3, nudge_x = .1, nudge_y = 0, hjust = 0, vjust = .5,
                fill = NA, label.color = NA, family = "titillium") +
  # aclaraciones
  geom_richtext(x = ac_10$x[1], y = ac_10$y[1], label = ac_10$label[1], 
                hjust = ac_10$hjust[1], vjust = ac_10$vjust[1], inherit.aes = FALSE, 
                color = "white", size = 3, fontface = "italic", family = "titillium", 
                fill = NA, label.color = NA) +
  geom_richtext(x = ac_10$x[2], y = ac_10$y[2], label = ac_10$label[2], 
                hjust = ac_10$hjust[2], vjust = ac_10$vjust[2], inherit.aes = FALSE, 
                color = "white", size = 3, fontface = "italic", family = "titillium", 
                fill = NA, label.color = NA) +
  # flechas
  geom_curve(x = fl_10$x[1], y = fl_10$y[1], xend = fl_10$xend[1], 
             yend = fl_10$yend[1], color = "white", inherit.aes = FALSE, 
             arrow.fill = "white", curvature = +.1, linewidth = .3, 
             arrow = arrow(angle = 10, length = unit(.3, "line"), type = "closed")) +
  geom_curve(x = fl_10$x[2], y = fl_10$y[2], xend = fl_10$xend[2], 
             yend = fl_10$yend[2], color = "white", inherit.aes = FALSE, 
             arrow.fill = "white", curvature = -.1, linewidth = .3, 
             arrow = arrow(angle = 10, length = unit(.3, "line"), type = "closed")) +
  # ejes
  scale_x_date(breaks = vec_fecha_break,
               date_labels = "'%y") +
  scale_y_continuous() +
  coord_cartesian(clip = "off") +
  theme_void() +
  theme(aspect.ratio = 1.5,
        axis.text.y = element_blank(),
        axis.text.x = element_text(family = "bebas", size = 23,
                                   color = alpha("grey30", 1)),
        panel.grid = element_blank(),
        panel.background = element_rect(fill = "black", color = NA),
        plot.background = element_rect(fill = "black", color = NA),
        plot.margin = margin(5, 5, 5, 5))

g_m1 <- ggplot() +
  # miniaturas IZQUIERDA
  geom_richtext(data = mini_izq, aes(x = x, y = y, label = mini),
                inherit.aes = FALSE, fill = "grey20", vjust = .5, hjust = .5) +
  geom_richtext(data = mini_izq, 
                aes(x = x-.6, y = y, label = glue("{let}.")),
                inherit.aes = FALSE, fill = NA, vjust = .5, hjust = .5,
                color = "grey30", label.color = NA, family = "bebas", size = 7) +
  # ejes
  scale_x_continuous(limits = c(-.6, .5)) +
  scale_y_continuous(limits = c(-4, 16)) +
  coord_cartesian(clip = "off") +
  theme_void() +
  theme(aspect.ratio = 3.8,
        panel.background = element_rect(fill = "black", color = NA),
        plot.background = element_rect(fill = "black", color = NA),
        plot.margin = margin(0, 0, 0, 0))

g_m3 <- ggplot() +
  # miniaturas DERECHA
  geom_richtext(data = mini_der, aes(x = x, y = y, label = mini),
                inherit.aes = FALSE, fill = "grey20", vjust = .5, hjust = .5) +
  geom_richtext(data = mini_der, 
                aes(x = x-.6, y = y, label = glue("{let}.")),
                # nudge_x = -.01,
                inherit.aes = FALSE, fill = NA, vjust = .5, hjust = .5,
                color = "grey30", label.color = NA, family = "bebas", size = 7) +
  # ejes
  scale_x_continuous(limits = c(-.6, .5)) +
  scale_y_continuous(limits = c(-4, 16)) +
  coord_cartesian(clip = "off") +
  theme_void() +
  theme(aspect.ratio = 3.8,
        panel.background = element_rect(fill = "black", color = NA),
        plot.background = element_rect(fill = "black", color = NA),
        plot.margin = margin(0, 0, 0, 0))

mini_usos <- HT_mini |> 
  count(u, sort = TRUE)

usos_h <- filter(mini_usos, u == "H") |> pull(n)
usos_j <- filter(mini_usos, u == "J") |> pull(n)
usos_f <- filter(mini_usos, u == "F") |> pull(n)

g_m_comp <- g_m1 + g_m2 + g_m3 + 
  # proporci칩n de c/plot
  plot_layout(widths = c(.8, 2, .8)) &
  plot_annotation(title = "MINIATURAS X <span style='color:#ffc10e;'>10</span>",
                  subtitle = glue("Las miniaturas de los episodios pueden agruparse en
                  <span style='color:#ffc10e;'>10 im치genes 칰nicas</span>. Del 
                  total, 3 (<span style='color:#ee4121;'>D</span>, 
                  <span style='color:#ee4121;'>**G**</span>, 
                  <span style='color:#ee4121;'>**I**</span>) fueron utilizadas una 
                  sola<br>vez. Las 칰ltimas dos miniaturas 
                  (<span style='color:#ee4121;'>**F**</span>, 
                  <span style='color:#ee4121;'>**J**</span>) fueron usados 
                  <span style='color:#ffc10e;'>{usos_j}</span> veces. 
                  <span style='color:#ee4121;'>Hoy Trasnoche Diario</span> tuvo 
                  su propio logo <span style='color:#ffc10e;'>{usos_h}</span> 
                  veces."),
                  caption = HT_caption,
                  theme = theme(
                    plot.background = element_rect(color = "grey30",
                                                   fill = "black"),
                    plot.title.position = "plot",
                    plot.title = element_markdown(size = 50, family = "friz_bold",
                                                  color = "#ee4121"),
                    plot.subtitle = element_markdown(color = "white", size = 12,
                                                           family = "titillium",
                                                           margin = margin(2, 0, 10, 0)),
                    plot.caption = element_markdown(hjust = .5, family = "titillium",
                                                    margin = margin(1, 0, 0, 0), size = 9),
                    plot.caption.position = "plot"))

ggsave(plot = g_m_comp,
       filename = here("fig/HT_10.png"),
       width = 22,
       height = 25,
       units = "cm",
       dpi = 300)

# texto

mini_u <- HT_mini |> 
  count(u)

mini_b <- pull(filter(mini_u, u == "B"), n)
mini_c <- pull(filter(mini_u, u == "C"), n)
mini_f <- pull(filter(mini_u, u == "F"), n)
mini_j <- pull(filter(mini_u, u == "J"), n)
mini_h <- pull(filter(mini_u, u == "H"), n)
```
:::

::: {.column-screen-inset-right}
![Distribuci칩n temporal del uso de las im치genes de los episodios. A izquierda y derecha pueden verse las 10 im치genes 칰nicas.](fig/HT_10.png){#fig-10 fig-align="center"}
:::

Junto con el an치lisis de texto, algo con lo que nunca hab칤a tratado era con archivos de im치genes. As칤 que intentar encontrarle sentido al operar con las im치genes de los episodios fue muy interesante.

Las im치genes de cada cap칤tulo (seg칰n lo encontrado en Spotify) est치n disponibles en tres resoluciones, 64, 300 y 640 p칤xeles, cuadradas. El primer paso fue descargar todas las im치genes y registrar la fecha de uso. Luego para agrupar los episodios por su imagen se calcul칩 en color promedio, que es representativo de todas aquellas im치genes repetidas. Para ello se descompuso cada imagen en sus colores b치sicos (rojo, verde, azul), se promedi칩 para todos los p칤xeles y se gener칩 un color individual para cada episodio. Luego se agrup칩 entre estos de acuerdo al color promedio.

Incluyendo <ht>HOY TRASNOCHE DIARIO</ht>, hay 14 im치genes 칰nicas. Existen dos pares cuya 칰nica diferencia es la presencia del logo de POSTA, se agruparon convenientemente quedando dos im치genes, **A** y **C**, de la @fig-10. Para el <ht>HOY PORONGA</ht> aparecen dos disponibles, aunque es una diferencia que no pude detectar visualmente, por lo se que unificaron (**E**). Algo similar sucede con el logo usado actualmente: aparecen dos conjuntos de im치genes, que claramente son las mismas (**J**). Descartando las versiones que a simple vista son id칠nticas, de las 14 im치genes 칰nicas, quedan 10, de la **A** a la **J**.

La **D** fue utilizada una 칰nica vez, en [2019](https://open.spotify.com/episode/6j1TkNXmVec8G7MU5KcwTL), al igual que la **G** en [2020](https://open.spotify.com/episode/6ITrKiYfcqmUKJWfH5vgiz). Muy reflejo de su 칠poca. La **I** fue un <ht>HOY PORONGA</ht> especial, dedicado a una [pel칤cula](https://open.spotify.com/episode/0EatJAAU4faIkxw1J7Zqb2) que se escuchaba poco y se entend칤a menos. Las im치genes tradicionales, ponele, que identifican a <ht>HOY TRASNOCHE</ht> son la **B** (7 usos), **C** (7), **F** (73) y **J** (75). Y <ht>HOY TRASNOCHE DIARIO</ht>, **H** (67), claro.

La imagen **E** que ilustra los <ht>HOY PORONGA</ht> fue usada en 5 oportunidades. [Ac치](https://www.instagram.com/p/BlYYvcLnjNh/) podemos ver el inicio de esta hermosa saga.

Es claro que ya encontraron su identidad en cuanto al logo, que con pocos cambios, viene siendo el mismo desde finales de 2018 (inicio de imagen **F**).

Personalmente me encanta la imagen **B**, donde vemos a las estrellas del podcast. Entiendo que el logo actual (**J**) ya es un cl치sico, pero me gustar칤a, al menos por una temporada, volver a ver a Flor y Calu.

Pueden ver las im치genes en los siguientes links: [A](https://raw.githubusercontent.com/vhgauto/ht/main/u_640/A.jpg), [B](https://raw.githubusercontent.com/vhgauto/ht/main/u_640/B.jpg), [C](https://raw.githubusercontent.com/vhgauto/ht/main/u_640/C.jpg), [D](https://raw.githubusercontent.com/vhgauto/ht/main/u_640/D.jpg), [E](https://raw.githubusercontent.com/vhgauto/ht/main/u_640/E.jpg), [F](https://raw.githubusercontent.com/vhgauto/ht/main/u_640/F.jpg), [G](https://raw.githubusercontent.com/vhgauto/ht/main/u_640/G.jpg), [H](https://raw.githubusercontent.com/vhgauto/ht/main/u_640/H.jpg), [I](https://raw.githubusercontent.com/vhgauto/ht/main/u_640/I.jpg), [J](https://raw.githubusercontent.com/vhgauto/ht/main/u_640/J.jpg).

# An치lisis de pel칤culas {#sec-pel}

::: {.column-screen-inset-right}
```{r 12_web_scrapping_datos}
# paquetes ----

library(TMDb)
library(rvest)

# caption q/uso en las siguientes figuras

fuente2 <- "<span style='color:#ee4121;'>Datos:</span> <span style='color:#ffc10e;'>{**TMDb**}</span>"
HT_caption2 <- glue("{fuente2} {sep} {autor} {sep} {icon_github} {icon_twitter} {usuario}")

# base de datos (al 20230317)
# as칤 no tengo que extraer todos los datos de nuevo
# verifico los t칤tulos nuevos y agrego a la base de datos
# tmdb_datos <- read_tsv(here("data/tmdb_datos.tsv"))

# Letterboxd ----

link_lista_letterboxd <- "https://letterboxd.com/matiasec/list/hoy-trasnoche-con-capitulo/detail/"

# cantidad de p치ginas que contienen la lista de pel칤culas
n_lista <- read_html(link_lista_letterboxd) |> 
  html_elements(xpath = "/html/body/div[1]/div/div/section/div[3]/div[3]/ul/li/a") |> 
  html_text() |> 
  as.numeric() |> 
  max()

# link base para la iteraci칩n con 'map()'
url_base <- "https://letterboxd.com/matiasec/list/hoy-trasnoche-con-capitulo/detail/page/"

# vector con todas las 
url_vector <- glue("{url_base}{1:{n_lista}}")

# funci칩n p/obtener el t칤tulo de la pel칤cula y el a침o de estreno
f_letterboxd <- function(x) {
  
  # t칤tulo y a침o
  ti_an <- read_html(x) |> 
    html_elements(xpath = "/html/body/div[1]/div/div/section/ul/li/div[2]/h2") |> 
    html_text()
  
  # armo un tibble
  v <- tibble(peli = ti_an) |> 
    # separo en t칤tulo y a침o
    separate(peli, c("titulo", "a침o"), sep = " (?=\\d{4}$)")
  
  return(v)
}

# tibble con los t칤tulos de las pel칤culas y el a침o de estreno
# pelis_titulo_a침o <- map(.x = url_vector, ~ f_letterboxd(x = .x)) |> 
#   list_rbind() |> 
#   mutate(a침o = as.numeric(a침o))

# TMDb ----

api_key <- "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"

# verifico pel칤culas nuevas
# NO considero Leaving Neverland & The Viewing
# no_peli <- c("Leaving Neverland", "The Viewing")
# nueva_peli <- pelis_titulo_a침o |> 
#   anti_join(tmdb_datos |> distinct(titulo, a침o),
#             by = join_by(titulo, a침o)) |> 
#   filter(!titulo %in% no_peli)

# b칰squeda de los t칤tulos y a침o de cada pel칤cula, obtengo el 'id'
f_id <- function(x, y) {
  id <- search_multi(api_key = api_key, query = x) |> 
    as_tibble() |> 
    unnest(everything()) |> 
    filter(title == x) |> 
    mutate(d = abs(year(ymd(release_date)) - y)) |>
    slice_min(order_by = d, n = 1) |> 
    slice_max(order_by = popularity, n = 1) |> 
    pull(id)
  
  return(id)
  
}

# obtengo el ID de c/pel칤cula de TMDb
# ~ 3 minutos
# pelis_id <- nueva_peli |>
#   mutate(id = map2(.x = titulo, .y = a침o,
#                    ~ f_id(x = .x, y = .y))) |>
#   unnest(id)

# obtengo toda la info 'crew' (list)
f_crew <- function(x) {
  movie_credits(api_key = api_key, id = x)$crew
}

# obtengo toda la info 'cast' (list)
f_cast <- function(x) {
  movie_credits(api_key = api_key, id = x)$cast
}

# obtengo el elenco a partir de 'cast' (data.frame)
f_elenco <- function(x) {
  x$name[1:5]
}

# obtengo la direcci칩n a partir de 'crew' (data.frame)
f_direccion <- function(x) {
  x |> 
    as_tibble() |> 
    filter(job == "Director") |> 
    pull(name)
}

# obtengo el gui칩n a partir de 'crew' (data.frame)
f_guion <- function(x) {
  x |> 
    as_tibble() |> 
    filter(job %in% c("Screenplay", "Writer", "Story")) |> 
    distinct(name) |> 
    pull(name)
}

# obtengo el g칠nero a partir de 'id' (data.frame)
f_genero <- function(x) {
  movie(api_key = api_key, id = x)$genre$name
}

# tibble con columnas p/crew y cast
# ~ 7 minutos
# pelis_crew_cast <- pelis_id |>
#   mutate(crew = map(.x = id, ~ f_crew(x = .x))) |>
#   mutate(cast = map(.x = id, ~ f_cast(x = .x)))

# obtengo elenco, direcci칩n, gui칩n y g칠nero
# ~ 3 minutos
# 6400 filas
# tmdb_datos1 <- pelis_crew_cast |>
#   mutate(elenco = map(.x = cast, ~ f_elenco(x = .x))) |>
#   mutate(direccion = map(.x = crew, ~ f_direccion(x = .x))) |>
#   mutate(guion = map(.x = crew, ~ f_guion(x = .x))) |>
#   mutate(genero = map(.x = id, ~ f_genero(x = .x))) |>
#   select(-id, -crew, -cast) |>
#   unnest(elenco) |>
#   unnest(direccion) |>
#   unnest(guion) |>
#   unnest(genero)

# agrego las pel칤culas que quedaron afuera
# Leaving Neverland & The Viewing AFUERA!
# 135 filas
# tmdb_datos2 <- pelis_titulo_a침o |> 
#   anti_join(tmdb_datos1 |> distinct(titulo), by = "titulo") |> 
#   # manualmente :(
#   mutate(id = c(420648, 479957, 470918, 552180, 517839, NA_real_, 536743, 834027,
#                 797594, NA_real_)) |> 
#   drop_na() |> 
#   mutate(crew = map(.x = id, ~ f_crew(x = .x))) |> 
#   mutate(cast = map(.x = id, ~ f_cast(x = .x))) |> 
#   mutate(elenco = map(.x = cast, ~ f_elenco(x = .x))) |> 
#   mutate(direccion = map(.x = crew, ~ f_direccion(x = .x))) |> 
#   mutate(guion = map(.x = crew, ~ f_guion(x = .x))) |> 
#   mutate(genero = map(.x = id, ~ f_genero(x = .x))) |> 
#   select(-id, -crew, -cast) |> 
#   unnest(elenco, keep_empty = TRUE) |> 
#   unnest(direccion, keep_empty = TRUE) |> 
#   unnest(guion, keep_empty = TRUE) |> 
#   unnest(genero, keep_empty = TRUE)

# combino ambas bases de datos
# tmdb_datos <- bind_rows(tmdb_datos, tmdb_datos1)

# guardo
# write_tsv(tmdb_datos, here("data/tmdb_datos.tsv"))

# 6680 filas
tmdb_datos <- read_tsv(here("data/tmdb_datos.tsv"))

```
:::

El primer paso para el an치lisis de las pel칤culas discutidas en <ht>HOY TRASNOCHE</ht> consiste en tener el listado entero de t칤tulos. Gracias a [esta](https://letterboxd.com/matiasec/list/hoy-trasnoche-con-capitulo/detail/) lista en Letterboxd pude llevar a cabo todo lo que se muestra a continuaci칩n.

<span style='background-color:#333333'>No estoy a cargo de dicha lista, no doy fe de que est칠n absolutamente todas las pel칤culas analizadas en todos los episodios, ni tampoco revis칠 una por una cada entrada. Le pegu칠 una le칤da general, me pareci칩 correcto y prosegu칤. Adem치s, jam치s voy a poner en tela de duda el trabajo de otro trasnochiter.</span>

De acuerdo con la descripci칩n de la lista, *No son pel칤culas mencionadas ni estrenos comentados, son pel칤culas a las que le dedicaron un cap칤tulo*. Adem치s, cada entrada posee el t칤tulo del episodio correspondiente. Servicio completo.

Esta secci칩n requiri칩 de *web scrapping*, que es obtener datos a partir de sitios web. Fue la primera vez que lo hice, as칤 que aprend칤 un mont칩n en el camino. El paquete principal que us칠 es [<code>{rvest}</code>](https://rvest.tidyverse.org/), junto con las herramientas de desarrollo del navegador de Internet, que permite inspeccionar los elementos de inter칠s. Pude obtener el t칤tulo de cada pel칤cula y el a침o de estreno.

A partir de la base de datos de [The Movie Database](https://www.themoviedb.org/) (TMDB), accesible a partir del paquete hom칩nimo en <code>R</code>, consegu칤 m치s datos. Con el t칤tulo y el a침o, pueden obtenerse las listas del elenco, el equipo de producci칩n, detalles t칠cnicos, entre otros.

La informaci칩n obtenida de las `r nrow(distinct(tmdb_datos, titulo))` pel칤culas listadas fue: elenco (@sec-pel-elenco), direcci칩n ([-@sec-pel-direccion]), guion ([-@sec-pel-guion]) y g칠nero ([-@sec-pel-genero]).

## Elenco {#sec-pel-elenco}

::: {.column-screen-inset-right}
```{r 13_elenco}
# 1.- elenco --------------------------------------------------------------

# cantidad de actores por pel칤cula

elenco_files <- list.files(path = here("pic/elenco"),
                           pattern = ".jpg",
                           full.names = TRUE)

elenco_tbl <- tmdb_datos |> 
  distinct(titulo, elenco, .keep_all = TRUE) |>
  group_by(titulo) |> 
  distinct(elenco, .keep_all = TRUE) |> 
  ungroup() |> 
  count(elenco, sort = TRUE) |> 
  filter(n >= 3) |> 
  inner_join(tmdb_datos, by = "elenco", multiple = "all") |> 
  arrange(desc(n), elenco) |> 
  distinct(elenco, titulo, n, a침o) |> 
  mutate(elenco = fct_inorder(elenco)) |>
  mutate(orden = as.numeric(elenco)) |>
  # TOP 10
  filter(orden <= 10) |> 
  arrange(elenco, a침o) |> 
  group_by(elenco, orden) |> 
  mutate(id = row_number()) |> 
  mutate(M = max(id)) |> 
  mutate(id = case_match(M, 6 ~ id, 5 ~ id + 1, 4 ~ id + 2, 3 ~ id + 3)) |> 
  ungroup() |> 
  mutate(base = str_replace_all(elenco, " ", "_") |> str_to_lower()) |> 
  mutate(base = glue("p_{base}.jpg")) |> 
  filter(orden <= 4) |> 
  mutate(img = glue("<img src='{here('pic/elenco')}/{base}' width='100' />")) |> 
  mutate(img = fct_inorder(img))

g_elenco_top <- ggplot(data = elenco_tbl, aes(x = 0, y = id)) +
  # lista t칤tulos
  geom_richtext(aes(label = titulo), color = "white", family = "titillium",
                size = 5,
                position = position_dodge(width = .8, preserve = "total"),
                hjust = 0, fill = NA, label.color = NA) +
  # a침o estreno
  geom_richtext(aes(label = a침o), color = "grey70", family = "mono",
                size = 3,
                position = position_dodge(width = .8, preserve = "total"),
                hjust = 0, fill = NA, label.color = NA, vjust = 1.1) +
  # elenco
  geom_text(aes(label = str_wrap(elenco, 20), y = 4, x = 6), family = "bebas",
            hjust = 0, vjust = .5, color = "#ffc10e", size = 10, nudge_x = 3) +
  # faceta
  facet_wrap(~ img, ncol = 1, scales = "free", strip.position = "left") +
  scale_x_continuous(limits = c(-.025, 9)) +
  scale_y_continuous(limits = c(1, 7)) +
  coord_cartesian(clip = "off", ylim = c(2, 6), expand = FALSE) +
  # ejes
  labs(x = NULL, y = NULL,
       title = "TE AMAMOS <span style='color:#ee4121;'>NIC</span><span style='font-family:fa-solid; color:#ee4121;'>&#xf004;</span>",
       subtitle = glue("El actor m치s visto es 
                       <span style='color:#ee4121;'>Nicolas Cage</span>, con 6
                       pel칤culas. Le siguen, con 5, <span style='color:#ee4121;'>Adam Driver</span><br>
                       (nuestro fletero favorito); luego 
                       <span style='color:#ee4121;'>Jessi Buckley</span> y 
                       <span style='color:#ee4121;'>Mia Goth</span>, ambas con 4 
                       entradas."),
       caption = HT_caption2) +
  theme_void() +
  theme(aspect.ratio = .8,
        axis.text = element_blank(),
        strip.text.y.left = element_markdown(angle = 0, vjust = .7,
                                             margin = margin(0, 20, 0, 0)),
        panel.grid.minor = element_blank(),
        panel.grid.major = element_blank(),
        panel.background = element_rect(fill = "black", color = NA),
        panel.spacing.y = unit(5, "line"),
        plot.background = element_rect(fill = "black", color = "grey30"),
        plot.margin = margin(5, 177, 5, 7),
        plot.title = element_markdown(size = 38,family = "friz_bold",
                                      color = "#ffc10e",
                                      margin = ,margin(0, 100, 0, 0)),
        plot.title.position = "plot",
        plot.subtitle = element_markdown(color = "white", size = 12,
                                         family = "titillium", hjust = 0,
                                         margin = margin(0, 0, 25, 0)),
        plot.caption = element_markdown(hjust = .5, family = "titillium",
                                        margin = margin(45, 0, 0, 0), size = 9))

ggsave(plot = g_elenco_top,
       filename = here("fig/HT_elenco.png"),
       width = 15,
       height = 27,
       units = "cm",
       dpi = 300)

# texto

resto_elenco <- tmdb_datos |> 
  distinct(titulo, elenco, .keep_all = TRUE) |>
  group_by(titulo) |> 
  distinct(elenco, .keep_all = TRUE) |> 
  ungroup() |> 
  count(elenco, sort = TRUE) |> 
  filter(n >= 3) |> 
  inner_join(tmdb_datos, by = "elenco", multiple = "all") |> 
  arrange(desc(n), elenco) |> 
  distinct(elenco, titulo, n, a침o) |> 
  mutate(elenco = fct_inorder(elenco)) |>
  mutate(orden = as.numeric(elenco)) |>
  # TOP 10
  filter(orden <= 10) |> 
  arrange(elenco, a침o) |> 
  group_by(elenco, orden) |> 
  mutate(id = row_number()) |> 
  mutate(M = max(id)) |> 
  mutate(id = case_match(M, 6 ~ id, 5 ~ id + 1, 4 ~ id + 2, 3 ~ id + 3)) |> 
  ungroup() |> 
  mutate(base = str_replace_all(elenco, " ", "_") |> str_to_lower()) |> 
  mutate(base = glue("p_{base}.jpg")) |> 
  group_by(elenco) |> 
  slice(1) |> 
  ungroup() |> 
  select(elenco, n) |> 
  mutate(elenco = as.character(elenco))

```
:::

::: {.column-screen-inset-right}
![Top 4 protagonistas del elenco m치s populares, y las pel칤culas en las que participaron.](fig/HT_elenco.png){#fig-11 fig-align="center"}
:::

Los datos del elenco extra칤dos v칤a TMDB contienen a todos los integrantes. Por lo que en un ranking donde se los incluye a todos, los primeros puestos est치n ocupados por actores muy secundarios. Pero mi idea es enfocarme en los protagonistas de cada pel칤cula. As칤 que limit칠 el an치lisis 칰nicamente a los primeros 5 actores y actrices. Usualmente son lo que cualquiera considerar칤a como los principales.

El primer puesto es para el querid칤simo (*me pongo de pie*) **Nic Cage**. Posee seis pel칤culas en total, y en la @sec-tex-big aparec칤a entre los pares de palabras m치s frecuentes. Con cinco est치 **Adam Driver**. Boca Campe칩n. Completan el top 4 **Jessie Buckley** y **Mia Goth**, con 4 pel칤culas cada una. Debo admitir que cuando vi el nombre de Jessie Buckley no ten칤a idea de qui칠n era. Perd칩n Jessie si est치s leyendo esto.

Puede notarse la reciente popularidad ascendente de Mia, que, de sus 5 pel칤culas vistas en <ht>HOY TRASNOCHE</ht>, tres son entre el a침o pasado y este.

El resto de los primeros diez puestos sigue con **`r resto_elenco$elenco[5]`** y **`r resto_elenco$elenco[4]`** con 4 pel칤culas cada una. Luego, con 3 aparecen **`r str_flatten_comma(resto_elenco$elenco[7:9])`** y **`r resto_elenco$elenco[10]`**.

## Direcci칩n {#sec-pel-direccion}

::: {.column-screen-inset-right}
```{r 14_direccion}
# 2.- direcci칩n -----------------------------------------------------------

direccion_files <- list.files(path = here("pic/direccion"),
                              pattern = ".jpg",
                              full.names = TRUE)

direccion_tbl <- tmdb_datos |> 
  distinct(titulo, direccion) |> 
  count(direccion, sort = TRUE) |> 
  filter(n >= 3) |> 
  inner_join(tmdb_datos, by = "direccion", multiple = "all") |> 
  arrange(desc(n), direccion) |> 
  distinct(direccion, titulo, n, a침o) |> 
  mutate(direccion = fct_inorder(direccion)) |>
  mutate(orden = as.numeric(direccion)) |>
  # TOP 10
  filter(orden <= 10) |> 
  arrange(direccion, a침o) |> 
  group_by(direccion, orden) |> 
  mutate(id = row_number()) |> 
  mutate(M = max(id)) |> 
  mutate(id = case_match(M, 4 ~ id, 3 ~ id + 1)) |> 
  ungroup() |> 
  mutate(base = str_replace_all(direccion, " ", "_") |> str_to_lower()) |> 
  mutate(base = glue("d_{base}.jpg")) |> 
  mutate(img = glue("<img src='{here('pic/direccion')}/{base}' width='100' />")) |> 
  mutate(img = fct_inorder(img))

g_direccion <- ggplot(data = direccion_tbl, aes(x = 0, y = id)) +
  # lista t칤tulos
  geom_richtext(aes(label = titulo), color = "white", family = "titillium",
                size = 5,
                position = position_dodge(width = .8, preserve = "total"),
                hjust = 0, fill = NA, label.color = NA) +
  # a침o estreno
  geom_richtext(aes(label = a침o), color = "grey70", family = "mono",
                size = 3,
                position = position_dodge(width = .8, preserve = "total"),
                hjust = 0, fill = NA, label.color = NA, vjust = 1.1) +
  # direccion
  geom_text(aes(label = str_wrap(direccion, 20), y = 3.5, x = 5), family = "bebas",
            hjust = 0, vjust = .5, color = "#ffc10e", size = 10, nudge_x = 3) +
  # faceta
  facet_wrap(~ img, ncol = 1, scales = "free", strip.position = "left") +
  scale_x_continuous(limits = c(-.025, 9)) +
  scale_y_continuous(limits = c(1, 5)) +
  coord_cartesian(clip = "off", ylim = c(2, 4.5), expand = FALSE) +
  # ejes
  labs(x = NULL, y = NULL,
       title = "STEVEN <span style='color:#ee4121;'>PASI칍N</span>",
       subtitle = glue("El director m치s popular de {HT} es 
                       <span style='color:#ee4121;'>Steven Soderbergh</span>, con<br>
                       4 pel칤culas. <span style='color:#ee4121;'>David Bruckner</span> 
                       y <span style='color:#ee4121;'>Jordan Peele</span>, con 3, completan 
                       la terna."),
       caption = HT_caption2) +
  theme_void() +
  theme(aspect.ratio = .8,
        axis.text = element_blank(),
        strip.text.y.left = element_markdown(angle = 0, vjust = 1,
                                             margin = margin(0, 20, 0, 0)),
        panel.grid.minor = element_blank(),
        panel.grid.major = element_blank(),
        panel.background = element_rect(fill = "black", color = NA),
        panel.spacing.y = unit(5, "line"),
        plot.background = element_rect(fill = "black", color = "grey30"),
        plot.margin = margin(5, 177, 5, 7),
        plot.title = element_markdown(size = 45,family = "friz_bold",
                                      color = "#ffc10e",
                                      margin = ,margin(0, 100, 0, 0)),
        plot.title.position = "plot",
        plot.subtitle = element_markdown(color = "white", size = 12,
                                         family = "titillium", hjust = 0,
                                         margin = margin(4, 0, 15, 0)),
        plot.caption = element_markdown(hjust = 4.5, family = "titillium",
                                        margin = margin(69, 0, 0, 0), size = 9),
        plot.caption.position = "plot")

ggsave(plot = g_direccion,
       filename = here("fig/HT_direccion.png"),
       width = 15,
       height = 21.8,
       units = "cm",
       dpi =  300)

# texto

resto_direccion <- tmdb_datos |> 
  distinct(titulo, direccion) |> 
  count(direccion, sort = TRUE) |> 
  filter(n == 2) |> 
  slice(1:10) 
```
:::

::: {.column-screen-inset-right}
![Los 3 directores con mayor cantidad de pel칤culas analizadas.](fig/HT_direccion.png){#fig-12 fig-align="center"}
:::

El director con m치s pel칤culas (4) vistas en <ht>HOY TRASNOCHE</ht> es **Steven Soderbergh**. **Davis Bruckner** y **Jordan Peele**, ambos con 3 pel칤culas, completan el podio. Pueden notar que Davis y Jordan repiten en el g칠nero de terror. M치s detalles en la @sec-pel-genero.

El resto de directores y directoras del top 10, con 2 pel칤culas cada uno, son: **`r str_flatten_comma(resto_direccion$direccion[1:9])`** y **`r resto_direccion$direccion[10]`**.

## Gui칩n {#sec-pel-guion}

::: {.column-screen-inset-right}
```{r 15_guion}

guion_files <- list.files(path = here("pic/guion"),
                          pattern = ".jpg",
                          full.names = TRUE)

guion_tbl <- tmdb_datos |> 
  distinct(titulo, guion) |> 
  count(guion, sort = TRUE) |> 
  filter(n >= 3) |> 
  drop_na(guion) |> 
  inner_join(tmdb_datos, by = "guion", multiple = "all") |> 
  arrange(desc(n), guion) |> 
  distinct(guion, titulo, n, a침o) |> 
  mutate(guion = fct_inorder(guion)) |>
  mutate(orden = as.numeric(guion)) |>
  # TOP 10
  filter(orden <= 10) |> 
  arrange(guion, a침o) |> 
  group_by(guion, orden) |> 
  mutate(id = row_number()) |> 
  mutate(M = max(id)) |> 
  mutate(id = case_match(M, 4 ~ id, 3 ~ id + 1)) |> 
  ungroup() |> 
  mutate(base = str_replace_all(guion, " ", "_") |> str_to_lower()) |> 
  mutate(base = glue("g_{base}.jpg")) |> 
  mutate(img = glue("<img src='{here('pic/guion')}/{base}' width='100' />")) |> 
  mutate(img = fct_inorder(img)) |> 
  filter(n == 4 | guion == "Mariano Llin치s")

g_guion <- ggplot(data = guion_tbl, aes(x = 0, y = id)) +
  # lista t칤tulos
  geom_richtext(aes(label = titulo), color = "white", family = "titillium",
                size = 5,
                position = position_dodge(width = .8, preserve = "total"),
                hjust = 0, fill = NA, label.color = NA) +
  # a침o estreno
  geom_richtext(aes(label = a침o), color = "grey70", family = "mono",
                size = 3,
                position = position_dodge(width = .8, preserve = "total"),
                hjust = 0, fill = NA, label.color = NA, vjust = 1.1) +
  # guion
  geom_text(aes(label = str_wrap(guion, 20), y = 3.5, x = 5), family = "bebas",
            hjust = 0, vjust = .5, color = "#ffc10e", size = 10, nudge_x = 3) +
  # faceta
  facet_wrap(~ img, ncol = 1, scales = "free", strip.position = "left") +
  scale_x_continuous(limits = c(-.025, 9)) +
  scale_y_continuous(limits = c(1, 5)) +
  coord_cartesian(clip = "off", ylim = c(2, 4.5), expand = FALSE) +
  # ejes
  labs(x = NULL, y = NULL,
       title = "STORY BY <span style='color:#ee4121'>...</span>",
       subtitle = "<span style='color:#ee4121'>James Wan</span> y 
       <span style='color:#ee4121'>Jordan Peele</span> comparten el 1<sup>er</sup> 
       puesto con 4 pel칤culas. Por<br>orgullo catastral, sigue 
       <span style='color:#ee4121'>Mariano Llin치s</span>, con 3. Adem치s la foto 
       es espectacular.",
       caption = HT_caption2) +
  theme_void() +
  theme(aspect.ratio = .8,
        axis.text = element_blank(),
        strip.text.y.left = element_markdown(angle = 0, vjust = 1,
                                             margin = margin(0, 20, 0, 0)),
        panel.grid.minor = element_blank(),
        panel.grid.major = element_blank(),
        panel.background = element_rect(fill = "black", color = NA),
        panel.spacing.y = unit(5, "line"),
        plot.background = element_rect(fill = "black", color = "grey30"),
        plot.margin = margin(5, 177, 5, 11),
        plot.title = element_markdown(size = 45,family = "friz_bold",
                                      color = "#ffc10e",
                                      margin = ,margin(0, 100, 0, 0)),
        plot.title.position = "plot",
        plot.subtitle = element_markdown(color = "white", size = 12,
                                         family = "titillium", hjust = 0,
                                         margin = margin(4, 0, 15, 0)),
        plot.caption = element_markdown(hjust = 4.5, family = "titillium", color = "white",
                                        margin = margin(62, 0, 0, 0), size = 9),
        plot.caption.position = "plot"
  )

ggsave(plot = g_guion,
       filename = here("fig/HT_guion.png"),
       width = 14.9,
       height = 21,
       units = "cm",
       dpi =  300)

# texto

resto_guion <- tmdb_datos |> 
  distinct(titulo, guion) |> 
  count(guion, sort = TRUE) |> 
  filter(n == 3 & guion != "Mariano Llin치s") |> 
  drop_na(guion)
```
:::

::: {.column-screen-inset-right}
![Se muestran los 3 guionistas m치s recurrentes y las pel칤culas que escribieron.](fig/HT_guion.png){#fig-13 fig-align="center"}
:::

Los datos extra칤dos de TMDB poseen una columna *job* (puesto de trabajo). Espec칤ficamente, me refiero a guionista a todas aquellas personas cuyo puesto sea <code>screenplay</code>, <code>writer</code> o <code>story</code>.

Los guionistas con mayor cantidad de pel칤culas son **James Wan** y **Jordan Peele**, ambos con 4.

Aparte de **Mariano Llin치s** con 3 pel칤culas, otros son: **`r str_flatten_comma(resto_guion$guion[1:2])`** y **`r resto_guion$guion[3]`**.

## G칠nero {#sec-pel-genero}

```{r 16_genero}
# separador entre el g칠nero y su porcentaje
# separ <- glue("<span style='font-size:12px;color:#4d4d4d;font-family:mono'>{str_flatten(rep('.', 50))}</span>")
separ <- str_flatten(rep('_', 20))

# dado que las pel칤culas suelen tener m칰ltiples g칠neros, y no uno 칰nico, tomo
# el primer g칠nero de la lista p/c pel칤cula
genero_tbl <- tmdb_datos |> 
  # considero TODOS los g칠nero inclu칤dos en c/pel칤cula
  count(genero, sort = TRUE) |> 
  mutate(porcentaje = n/sum(n)*100) |> 
  mutate(sum_acumulada = cumsum(porcentaje)) |> 
  mutate(genero = fct_lump_n(f = genero, n = 10)) |> 
  filter(sum_acumulada < 91) |>
  mutate(valor = 100 - sum_acumulada) |> 
  mutate(eje_y = lag(valor)) |> 
  mutate(eje_y = if_else(is.na(eje_y), 100, eje_y)) |> 
  group_by(genero) |> 
  mutate(y = mean(c(valor, eje_y))) |> 
  ungroup() |> 
  mutate(genero = tolower(genero)) |> 
  mutate(genero = case_match(genero,
                             "horror" ~ "terror",
                             "comedy" ~ "comedia",
                             "action" ~ "acci칩n",
                             "crime" ~ "crimen",
                             "science fiction" ~ "ciencia ficci칩n",
                             "music" ~ "m칰sica",
                             "fantasy" ~ "fantas칤a",
                             "mystery" ~ "misterio",
                             .default = genero)) |> 
  mutate(etq = glue("<span style='font-size:{porcentaje*7}px'>{genero}</span><span style='font-size:12px;color:#4d4d4d;font-family:mono'>{separ}</span><span style='font-size:15px;color:#ffc10e;font-family:mono'>{round(porcentaje)}%</span>"))

vec_resto_genero <- tmdb_datos |> 
  count(genero, sort = TRUE) |> 
  mutate(porcentaje = n/sum(n)*100) |> 
  mutate(sum_acumulada = cumsum(porcentaje)) |> 
  mutate(genero = fct_lump_n(f = genero, n = 10)) |> 
  filter(sum_acumulada > 91) |>
  mutate(valor = 100 - sum_acumulada) |> 
  mutate(genero = as.character(genero)) |> 
  mutate(suma = sum(valor)) |> 
  mutate(genero = tolower(genero)) |> 
  # traducci칩n
  mutate(genero = case_match(genero,
                             "documentary" ~ "documental",
                             "music" ~ "m칰sica",
                             "mystery" ~ "misterio",
                             "adventure" ~ "aventura",
                             "fantasy" ~ "fantas칤a",
                             "history" ~ "hist칩rica",
                             "animation" ~ "animaci칩n",
                             "family" ~ "familiar",
                             "tv movie" ~ "para televisi칩n",
                             "war" ~ "b칠lica",
                             .default = genero)) |> 
  pull(genero)

resto_genero_tbl <- tibble(x = 0,
                           y = 10.5,
                           label = str_wrap(str_flatten_comma(vec_resto_genero), 
                                            width = 50)) |> 
  mutate(label = str_replace_all(label, "\\n", "<br>")) |> 
  mutate(etq = glue("{label}<span style='font-size:12px;color:#4d4d4d;font-family:mono'>{separ}</span><span style='font-size:15px;color:#ffc10e;font-family:mono'>{100-sum(round(genero_tbl$porcentaje))}%</span>"))

lim_tbl <- tibble(x = .5,
                  y = c(0, 100))

puesto1 <- arrange(genero_tbl, desc(porcentaje)) |> slice(1) |> pull(porcentaje) |> round()
genero1 <- arrange(genero_tbl, desc(porcentaje)) |> slice(1) |> pull(genero)

puesto2 <- arrange(genero_tbl, desc(porcentaje)) |> slice(2) |> pull(porcentaje) |> round()
genero2 <- arrange(genero_tbl, desc(porcentaje)) |> slice(2) |> pull(genero)

puesto3 <- arrange(genero_tbl, desc(porcentaje)) |> slice(3) |> pull(porcentaje) |> round()
genero3 <- arrange(genero_tbl, desc(porcentaje)) |> slice(3) |> pull(genero)

puesto4 <- arrange(genero_tbl, desc(porcentaje)) |> slice(4) |> pull(porcentaje) |> round()
genero4 <- arrange(genero_tbl, desc(porcentaje)) |> slice(4) |> pull(genero)

suma_top4_puesto <- puesto1 + puesto2 + puesto3 + puesto4

g_genero <- ggplot(data = genero_tbl,
                  aes(x = 0, y = valor, 
                      size = I(porcentaje*2), 
                      label = etq)) +
  # g칠nero
  geom_richtext(show.legend = FALSE, hjust = 0, fill = NA, label.color = NA,
                family = "bebas", color = "#ee4121",vjust = 0) +
  # resto
  geom_richtext(data = resto_genero_tbl, inherit.aes = FALSE,
                aes(x, y, label = etq), show.legend = FALSE, hjust = 0, fill = NA, label.color = NA,
                family = "bebas", color = "#ee4121",vjust = 1) +
  # manual
  scale_x_continuous(limits = c(0, 1),
                     expand = c(0, 0)) +
  scale_y_continuous(limits = c(5, 100),
                     expand = c(0, 0)) +
  coord_cartesian(clip = "off") +
  # ejes
  labs(x = NULL, y = NULL,
       title = "DRAMA<span style='color:#ee4121'>QUEENS</span>",
       subtitle = glue("El g칠nero m치s frecuente es el 
                       <span style='color:#ee4121'>{genero1}</span> con el 
                       <span style='color:#ffc10e'>{puesto1}%</span>. Siguen de 
                       cerca <span style='color:#ee4121'>{genero2}</span> y<br>
                       <span style='color:#ee4121'>{genero3}</span>, 
                       con <span style='color:#ffc10e'>{puesto2}%</span>. 
                       Contin칰a <span style='color:#ee4121'>{genero4}</span> 
                       (<span style='color:#ffc10e'>{puesto4}%</span>) y el resto 
                       de g칠neros no supera el <span style='color:#ffc10e'>10%</span>."),
       caption = HT_caption2) +
  theme_void() +
  theme(aspect.ratio = 1,
        axis.text = element_blank(),
        strip.text.y.left = element_markdown(angle = 0, vjust = 1,
                                             margin = margin(0, 20, 0, 0)),
        panel.grid.minor = element_blank(),
        panel.grid.major = element_blank(),
        panel.background = element_rect(fill = "black", color = NA),
        panel.spacing.y = unit(5, "line"),
        plot.background = element_rect(fill = "black", color = "grey30"),
        plot.margin = margin(5, 5, 0, 5),
        plot.title = element_markdown(color = "#ffc10e", size = 46,
                                      family = "friz_bold",
                                      margin = margin(0, 5, 0, 0)),
        plot.title.position = "plot",
        plot.subtitle = element_markdown(color = "white", size = 12,
                                         family = "titillium", hjust = 0,
                                         margin = margin(4, 0, 10, 0)),
        plot.caption = element_markdown(hjust = .5, family = "titillium", 
                                        color = "white", size = 9,
                                        margin = margin(27, 0, 5, 0)),
        plot.caption.position = "plot")

ggsave(plot = g_genero,
      filename = here("fig/HT_genero.png"),
      width = 14.9,
      height = 19.2,
      units = "cm",
      dpi = 300)

```

::: {.column-screen-inset-right}
![G칠neros m치s frecuentes entre todas las pel칤culas analizadas. Se indica el valor del porcentaje que representa del total.](fig/HT_genero.png){#fig-14 fig-align="center"}
:::

El primer puesto de g칠neros m치s frecuentes lo ocupa **`r genero1`** (`r puesto1`%). Siguen **`r genero2`** y **`r genero3`**, ambos con `r puesto2`%. Junto con **`r genero4`** (`r puesto4`%), estos cuatro g칠neros engloban el `r suma_top4_puesto`% de todas las pel칤culas.

Cada pel칤cula posee multiplicidad de g칠neros involucrados. Es poco frecuente encontrar pel칤culas mono-g칠nero. Por lo tanto, consider칠 todos los g칠neros disponibles para cada pel칤cula, sin recortar ninguno. Seguramente esto haya causado que drama aparezca en el primer puesto, ya que es un g칠nero tan abarcador.

No aparece el g칠nero favorito de todos los trasnochiter, el de un profesional de la gran ciudad que vuelve a su pueblo natal para encontrarse con su pasado y 

# Conclusiones {.unnumbered}

Sobre los resultados obtenidos, podemos ver que la producci칩n de cap칤tulos no para. No solamente son m치s largos (@fig-01), sino que cada a침o hay m치s contenido (@fig-02). Si hay un nuevo <ht>HOY TRASNOCHE</ht> significa que es viernes (@fig-03). La regularidad de episodios tambi칠n se estabiliz칩 (toco madera). Desde abril de 2021 tenemos episodios todos los meses (@fig-04).

Del an치lisis de texto, surgen resultados que tenemos m치s presentes, porque tratan del contenido mismo de los episodios (nadie anda contando cu치ntos cap칤tulos salen en agosto, o cu치ntos minutos dura cada episodio). Que Fiorella es **Fio** y Santiago es **Calu** (figura 3.1). Que las palabras m치s recurrentes son poronga, pel칤cula, caca, cine y semana (figura 3.2). Nunca hab칤a sentido tanta satisfacci칩n de ver la palabra 游깯poronga游깯. Un an치lisis que personalmente me pareci칩 muy interesante fue el de las palabras m치s importantes (@fig-08). Fue como entrar en una m치quina del tiempo. Recordar el videoclub de Calu, el portarretratos con y sin perspectiva de g칠nero, las locas aventuras de Laffie, la aparici칩n de Oti en nuestras vidas. En el bigrama (@fig-09) se ven claro los participantes de las coyunturas. La secci칩n policial con los 칰ltimos delitos de Ezra Miller, y vimos en tiempo real la cancelaci칩n de Armie Hammer.

Respecto de las im치genes que ilustran los episodios, vemos una continuidad en el estilo (@fig-10). La imagen actual y la anterior son muy similares, mostrando un dise침o establecido y (a esta altura) f치cilmente reconocible. Vale mencionar los casos aislados, como los escasos <ht>HOY PORONGA</ht>.

A partir de las pel칤culas analizadas en los episodios vemos el favoritismo por **Nicolas Cage** (@fig-11), totalmente justificado. **Steven Soderbergh**, **James Wan** y **Jordan Peele** son las mentes creativas que m치s nos cautivan (@fig-12 y [-@fig-13]). El **drama**, el **terror** y el **thriller** son los g칠neros que m치s abundan (@fig-14). Aunque entiendo que puede haber una sobrepoblaci칩n de *drama*, por el sentido amplio de la palabra.

# Gracias {.unnumbered}

**Flor** y **Calu**, los escucho desde el primer episodio y me acompa침aron en muchos momentos, de los buenos y de los otros. Me he re칤do como nunca en el transporte p칰blico gracias a ustedes. Aprendo un mont칩n escuch치ndolos, de la industria del cine, de su historia, de la producci칩n de pel칤culas, de narrativa, de interpretaci칩n. Si hay una cosa por las que voy a estar eternamente agradecidos con ustedes es que me hicieron amar a칰n m치s el cine. S칠 que no soy el 칰nico que coincide conmigo. El pueblo trasnochiter eternamente agradecido.

<br><br>

Hacer todo esto llev칩 una cantidad de tiempo insalubre. Eso m치s que nada habla de mis (in)habilidades en la programaci칩n y redacci칩n. Sin embargo, lo disfrut칠 much칤simo. Aprender nuevas funciones de <code>R</code>, plasmar en el script aquello que ten칤a en la mente y despu칠s visualizarlo es algo sumamente satisfactorio. Encontrarme con un problema, buscar potenciales soluciones, y golpearme la cabeza contra la pared hasta hallar la soluci칩n, no siempre de manera elegante, pero s칤 funcional. Respecto de las visualizaciones, probar diferentes gr치ficos, que no salga como quer칠s, borrar todo y empezar de nuevo. Meterme en temas totalmente desconocidos y salir con conocimientos nuevos, como manipular texto e im치genes, y extraer datos de Internet con web scrapping.

Si habiendo le칤do todo, llegaste hasta ac치, espero haya sido una experiencia interesante. Muchas gracias.

Si por alguna raz칩n le pegaste una le칤da al c칩digo que hay bajo cada figura, espero no haberte espantado. Seguramente haya mil cosas por mejorar, optimizar, aclarar y ajustar. Es m치s, de ac치 a un par de a침os yo mismo voy a ver estos scripts y me voy a querer m4t4r.

Si revisando el c칩digo encontraste algo grave, chifl치. No lo dudes.

Si te gustan las infograf칤as, tom칠 mucha inspiraci칩n de [chartr](https://read.chartr.co/) y [VISUAL CAPITALIST](https://www.visualcapitalist.com/).

Este proyecto me permiti칩 aprender muchas cosas y afianzar conocimientos y t칠cnicas de extracci칩n, procesamiento y visualizaci칩n de datos. Esta idea surgi칩 a partir de los objetivos planteados por [Tidy Tuesday](https://github.com/rfordatascience/tidytuesday). Trabajar con datos *de la realidad*, practicar y aprender.

Y si te gust칩, ac치 abajo en los comentarios d칠jame un emoji de 游댠, dale a la campanita y dale me gusta que me ayud치s un mont칩n.

<br><br>

Este reporte, el c칩digo de programaci칩n que lo cre칩, las im치genes usadas y las bases de datos est치n disponibles en [este](https://github.com/vhgauto/ht) repositorio en GitHub. Me encuentran en [Twitter](https://twitter.com/vhgauto) e [Instagram](https://www.instagram.com/vhgauto/).

<br><br><br>

::: {.column-screen}
![](fig/u.png){fig-align="center"}
:::